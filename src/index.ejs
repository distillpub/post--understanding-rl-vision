<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://distill.pub/template.v2.js"></script>
  <style>
    <%=require("raw-loader!../static/style.css").default %>
  </style>
</head>

<body>

  <d-front-matter>
    <script type="text/json">{
      "title": "Understanding RL vision",
      "description": "With diverse environments, we can analyze, diagnose and edit deep reinforcement learning models using attribution.",
      "authors": [
        {
          "author": "Jacob Hilton",
          "authorURL": "https://www.jacobh.co.uk/",
          "affiliation": "OpenAI",
          "affiliationURL": "https://openai.com"
        },
        {
          "author": "Nick Cammarata",
          "authorURL": "http://nickcammarata.com/",
          "affiliation": "OpenAI",
          "affiliationURL": "https://openai.com"
        },
        {
          "author": "Shan Carter",
          "authorURL": "http://shancarter.com/",
          "affiliation": "Observable",
          "affiliationURL": "http://observablehq.com/"
        },
        {
          "author": "Gabriel Goh",
          "authorURL": "http://gabgoh.github.io/",
          "affiliation": "OpenAI",
          "affiliationURL": "https://openai.com"
        },
        {
          "author": "Chris Olah",
          "authorURL": "https://colah.github.io/",
          "affiliation": "OpenAI",
          "affiliationURL": "https://openai.com"
        }
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  <d-title>
    <h1>Understanding RL vision</h1>
    <p>With diverse environments, we can analyze, diagnose and edit deep reinforcement learning models using attribution.</p>
    <figure id="hero" style="margin-top: 1em; margin-bottom: 0.5em; width: 100%;">
      <table style="margin-bottom: 1.5em; width: 100%;">
        <tr>
          <th>Observation <span style="font-weight: normal;">(video game still)</span></th>
          <th>Positive attribution <span style="font-weight: normal;">(good news)</span></th>
          <th>Negative attribution <span style="font-weight: normal;">(bad news)</span></th>
        </tr>
        <tr>
          <td style="width: 40%;" rowspan="2">
            <div class="hero-outer">
              <div class="hero-inner" style="z-index: 0;">
                <div id="hero-observation" class="hero-image" style="background-image: url('images/hero/observation.png');"></div>
              </div>
            </div>
          </td>
          <td style="height: 1px; width: 30%;">
            <div class="hero-outer">
              <div class="hero-inner" style="z-index: 0;">
                <div class="hero-image grayscale-light" style="background-image: url('images/hero/observation.png');"></div>
              </div>
              <div class="hero-inner" style="z-index: 1;">
                <div id="hero-overlay-pos" class="hero-image" style="background-image: url('images/hero/attribution_pos.png');"></div>
              </div>
            </div>
          </td>
          <td style="height: 1px; width: 30%;">
            <div class="hero-outer">
              <div class="hero-inner" style="z-index: 0;">
                <div class="hero-image grayscale-light" style="background-image: url('images/hero/observation.png');"></div>
              </div>
              <div class="hero-inner" style="z-index: 1;">
                <div id="hero-overlay-neg" class="hero-image" style="background-image: url('images/hero/attribution_neg.png');"></div>
              </div>
            </div>
          </td>
        </tr>
        <tr>
          <td colspan="2">
            <div id="hero-annotations" style="height: 100%;">
              <div style="width: 47%; text-align: left; line-height: 1.5em;">
                Attribution from a hidden layer to the value function, showing what features of the observation (left) are used to predict success (middle) and failure (right). Applying dimensionality reduction (NMF) yields features that detect various in-game objects.
              </div>
              <div style="top: 0px; left: 49%;">
                <img id="hero-annotation-1" src="images/hero/coin.png" class="hero-annotation-image">
                <br>
                <div class="hero-annotation-dot" style="background-color: #ffe400;"></div> Coin
                <div id="hero-annotation-lines-1" style="display: block;">
                  <div class="hero-annotation-line-vertical-outer">
                    <div class="hero-annotation-line-vertical-inner"></div>
                  </div>
                  <div class="hero-annotation-line-horizontal-outer" style="left: -23px; width: 76px;">
                    <div class="hero-annotation-line-horizontal-inner" style="width: 74px;"></div>
                  </div>
                </div>
              </div>
              <div style="top: 0px; left: 67.75%;">
                <img id="hero-annotation-2" src="images/hero/enemy.png" class="hero-annotation-image">
                <br>
                <div class="hero-annotation-dot" style="background-color: #a1ff00;"></div> Enemy
                <div id="hero-annotation-lines-2" style="display: block;">
                  <div class="hero-annotation-line-vertical-outer">
                    <div class="hero-annotation-line-vertical-inner"></div>
                  </div>
                  <div class="hero-annotation-line-horizontal-outer" style="left: 47px; width: 27px;">
                    <div class="hero-annotation-line-horizontal-inner" style="left: 2px; width: 25px;"></div>
                  </div>
                </div>
              </div>
              <div style="top: 0px; left: 86.5%;">
                <img id="hero-annotation-0" src="images/hero/saw.png" class="hero-annotation-image">
                <br>
                <div class="hero-annotation-dot" style="background-color: #ff0000;"></div> Buzzsaw
                <div id="hero-annotation-lines-0" style="display: block;">
                  <div class="hero-annotation-line-vertical-outer">
                    <div class="hero-annotation-line-vertical-inner"></div>
                  </div>
                  <div class="hero-annotation-line-horizontal-outer" style="left: 5px; width: 48px;">
                    <div class="hero-annotation-line-horizontal-inner" style="width: 46px;"></div>
                  </div>
                </div>
              </div>
            </div>
          </td>
        </tr>
      </table>
    </figure>
  </d-title>

  <d-article>

    <d-contents>
      <nav class="l-text figcaption">
        <h3>Contents</h3>
        <div><a href="#introduction">Introduction</a></div>
        <div><a href="#coinrun">Our CoinRun model</a></div>
        <div><a href="#analysis">Model analysis</a></div>
        <ul>
          <li><a href="#dissecting-failure">Dissecting failure</a></li>
          <li><a href="#hallucinations">Hallucinations</a></li>
          <li><a href="#model-editing">Model editing</a></li>
        </ul>
        <div><a href="#diversity-hypothesis">The diversity hypothesis</a></div>
        <div><a href="#feature-visualization">Feature visualization</a></div>
        <div><a href="#attribution">Attribution</a></div>
        <div><a href="#questions">Questions for further research</a></div>
      </nav>
    </d-contents>

    <div>
      <p id="introduction">
        In this article, we apply interpretability techniques to a reinforcement learning (RL) model trained to play the video game CoinRun <d-cite key="coinrunpaper"></d-cite>. Using attribution <d-cite key="attribution1,attribution2,attribution3,gradcam,attribution4,attribution5,attribution6,integratedgradients"></d-cite> combined with dimensionality reduction as in <d-cite key="buildingblocks"></d-cite>, we build an interface for exploring the objects detected by the model, and how they influence its value function and policy. We leverage this interface in several ways.
      </p>
      <ul>
        <li><b><a href="#dissecting-failure">Dissecting failure</a>.</b> We perform a step-by-step analysis of the agent's behavior in cases where it failed to achieve the maximum reward, allowing us to understand what went wrong, and why. For example, one case of failure was caused by an obstacle being temporarily obscured from view.</li>
        <li><b><a href="#hallucinations">Hallucinations</a>.</b> We find situations when the model "hallucinated" a feature not present in the observation, thereby explaining inaccuracies in the model's value function. These were brief enough that they did not affect the agent's behavior.</li>
        <li><b><a href="#model-editing">Model editing</a>.</b> We hand-edit the weights of the model to blind the agent to certain hazards, without otherwise changing the agent's behavior. We verify the effects of these edits by checking which hazards cause the new agents to fail. Such editing is only made possible by our previous analysis, and thus provides a quantitative validation of this analysis.</li>
      </ul>
      <p>
        Our results depend on levels in CoinRun being procedurally-generated, leading us to formulate a <span style="font-style: italic;"><a href="#diversity-hypothesis">diversity hypothesis</a></span> for interpretability. If it is correct, then we can expect RL models to become more interpretable as the environments they are trained on become more diverse. We provide evidence for our hypothesis by measuring the relationship between interpretability and generalization.
      </p>
      <p>
        Finally, we provide a thorough <a href="#feature-visualization">investigation</a> of several interpretability techniques in the context of RL vision, and pose a number of <a href="#questions">questions</a> for further research.
      </p>
    </div>
    <h2 id="coinrun">Our CoinRun model</h2>
    <p>
      CoinRun is a side-scrolling platformer in which the agent must dodge enemies and other traps and collect the coin at the end of the level.
    </p>
    <figure>
      <video style="width: 100%;" loop controls muted>
        <source src="videos/coinrun.mp4" type="video/mp4">
      </video>
      <figcaption style="text-align: center;">Our trained model playing CoinRun. <b>Left</b>: full resolution. <b>Right</b>: 64x64 RGB observations given to the model.</figcaption>
    </figure>
    <p>
      CoinRun is procedurally-generated, meaning that each new level encountered by the agent is randomly generated from scratch. This incentivizes the model to learn how to spot the different kinds of objects in the game, since it cannot get away with simply memorizing a small number of specific trajectories <d-cite key="procgen"></d-cite>.<d-footnote>We use the original version of CoinRun <d-cite key="coinrunpaper"></d-cite>, not the version from Procgen Benchmark <d-cite key="procgen"></d-cite>, which is slightly different. To play CoinRun yourself, please follow the instructions <a href="https://github.com/openai/coinrun">here</a>.</d-footnote>
    </p>
    <p>
      Here are some examples of the objects used, along with walls and floors, to generate CoinRun levels.
    </p>
    <figure id="coinrun-objects">
      <table>
        <tr class="coinrun-objects-row-images">
          <td style="font-weight: bold; white-space: normal;">Full resolution</td>
          <td>
            <img src="images/coinrun/agent_0_human.png" class="coinrun-object-double">
            <img src="images/coinrun/agent_1_human.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/coin_1_human.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/saw_1_human.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/enemy_0_human.png" class="coinrun-object-double">
            <img src="images/coinrun/enemy_1_human.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/box_0_human.png" class="coinrun-object-double">
            <img src="images/coinrun/box_1_human.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/lava_human.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/velocity_info_human.png" class="coinrun-object-single">
          </td>
        </tr>
        <tr class="coinrun-objects-row-images">
          <td style="font-weight: bold; white-space: normal;">Model resolution</td>
          <td>
            <img src="images/coinrun/agent_0_model.png" class="coinrun-object-double">
            <img src="images/coinrun/agent_1_model.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/coin_1_model.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/saw_1_model.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/enemy_0_model.png" class="coinrun-object-double">
            <img src="images/coinrun/enemy_1_model.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/box_0_model.png" class="coinrun-object-double">
            <img src="images/coinrun/box_1_model.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/lava_model.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/velocity_info_model.png" class="coinrun-object-single">
          </td>
        </tr>
        <tr class="coinrun-objects-row-text">
          <td></td>
          <td><figcaption>The agent, in mid air (left) and about to jump (right). The agent also appears in beige, blue and green.</figcaption></td>
          <td><figcaption>Coins, which have to be collected.</figcaption></td>
          <td><figcaption>Stationary buzzsaw obstacles, which must be dodged.</figcaption></td>
          <td><figcaption>Enemies, which must be dodged, moving left and right. There are several alternative sprites, all with white trails.</figcaption></td>
          <td><figcaption>Boxes, which the agent can both move past and land on top of.</figcaption></td>
          <td><figcaption>Lava at the bottom of a chasm.</figcaption></td>
          <td><figcaption>The velocity info painted into the top left of each observation, indicating the agent's horizontal and vertical velocities.<d-footnote class="velocity-info-footnote">Painting in the velocity info allows the model to infer the agent's motion from a single frame. The shade of the left square indicates the agent's horizontal velocity (black for left at full speed, white for right at full speed), and the shade of the right square indicates the agent's vertical velocity (black for down at full speed, white for up at full speed). In this example, the agent is moving forward and about to land (and is thus moving right and down).</d-footnote></figcaption></td>
        </tr>
      </table>
    </figure>
    <p>
      There are 9 actions available to the agent in CoinRun:
    </p>
    <figure id="coinrun-actions">
      <table>
        <tr>
          <td><span class="coinrun-action">&#8592;</span></td>
          <td><span class="coinrun-action">&#8594;</span></td>
          <td></td>
          <td><figcaption>Left and right change the agent's horizontal velocity. They still work while the agent is in mid-air, but have less of an effect.</figcaption></td>
        </tr>
        <tr>
          <td><span class="coinrun-action">&#8595;</span></td>
          <td></td>
          <td></td>
          <td><figcaption>Down cancels a jump if used immediately after up, and steps the agent down from boxes.</figcaption></td>
        </tr>
        <tr>
          <td><span class="coinrun-action">&#8593;</span></td>
          <td><span class="coinrun-action">&#8598;</span></td>
          <td><span class="coinrun-action">&#8599;</span></td>
          <td><figcaption>Up causes the agent to jump after the next non-up action. Diagonal directions have the same effect as both component directions combined.</figcaption></td>
        </tr>
        <tr>
          <td><span class="coinrun-action">A</span></td>
          <td><span class="coinrun-action">B</span></td>
          <td><span class="coinrun-action">C</span></td>
          <td><figcaption>A, B and C do nothing.<d-footnote>The original version of CoinRun only has 1 "do nothing" action, but our version ended up with 3 when "A" and "B" actions were added to be used in other games. For consistency, we have relabeled the original "do nothing" action as "C".</d-footnote></figcaption></td>
        </tr>
      </table>
    </figure>
    <p>
      We trained a convolutional neural network on CoinRun for around 2 billion timesteps, using PPO <d-cite key="ppo"></d-cite>, an actor-critic algorithm.<d-footnote>We used the standard PPO hyperparameters for CoinRun <d-cite key="coinrunpaper"></d-cite>, except that we used twice as many copies of the environment per worker and twice and many workers. The effect of these changes was to increase the effective batch size, which seemed to be necessary to reach the same performance with our smaller architecture.</d-footnote> The architecture of our network is described in <a href="#architecture">Appendix C</a>. We used a non-recurrent network, to avoid any need to visualize multiple frames at once. Thus our model observes a single downsampled 64x64 image, and outputs a value function (an estimate of the total future time-discounted reward) and a policy (a probability distribution over the actions, from which the next action is sampled).
    </p>
    <figure style="text-align: center;">
      <svg height="160px" width="448px">
        <defs>
          <marker id="arrow-model" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,6 L9,3 z" fill="#000000" />
          </marker>
        </defs>
        <image xlink:href="images/coinrun/observation.png" x="8" y="16" height="96" width="96" style="image-rendering: pixelated;"></image>
        <rect x="8" y="16" height="96" width="96" fill="none" stroke="#808080" stroke-width="1"></rect>
        <text x="56" y="135" text-anchor="middle">observation</text>
        <line x1="104" y1="64" x2="152" y2="64" stroke="#000000" stroke-width="1" marker-end="url(#arrow-model)"></line>
        <text x="180" y="69" text-anchor="middle">CNN</text>
        <rect x="152" y="36" height="56" width="56" fill="none" stroke="#000000" stroke-width="1"></rect>
        <path d="M 208 64 h 24 q 8 0, 8 -8 v -40 q 0 -8, 8 -8 h 24" fill="none" stroke="#000000" stroke-width="1" marker-end="url(#arrow-model)"></path>
        <path d="M 232 64 q 8 0, 8 8 q 0 8, 8 8 h 24" fill="none" stroke="#000000" stroke-width="1" marker-end="url(#arrow-model)"></path>
        <rect x="278" y="0" height="16" width="16" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="4" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <text x="300" y="13" text-anchor="start">value function</text>
        <rect x="278" y="24" height="112" width="16" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="28" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="40" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="52" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="64" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="76" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="88" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="100" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="112" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="124" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <text x="286" y="152" text-anchor="middle">logits</text>
        <line x1="300" y1="80" x2="380" y2="80" stroke="#000000" stroke-width="1" marker-end="url(#arrow-model)"></line>
        <text x="340" y="102" text-anchor="middle">softmax</text>
        <text x="388" y="84" text-anchor="start">policy</text>
      </svg>
      <figcaption>Schematic of a typical non-recurrent convolutional actor-critic model, such as ours.</figcaption>
    </figure>
    <p>
      Since the only available reward is a fixed bonus for collecting the coin, the value function estimates the time-discounted<d-footnote>We use a discount rate of 0.999 per timestep.</d-footnote> probability that the agent will successfully complete the level.
    </p>
    <h2 id="analysis">Model analysis</h2>
    <p>
      Having trained a strong RL agent, we were curious to see what it had learned. Following <d-cite key="buildingblocks"></d-cite>, we developed an interface for examining trajectories of the agent playing the game. This incorporates attribution from a hidden layer that recognizes objects, which serves to highlight objects that positively or negatively influence a particular network output. By applying dimensionality reduction, we obtain attribution vectors whose components correspond to different types of object, which we indicate using different colors.
    </p>
    <p id="interface">
      Here is our interface for a typical trajectory, with the value function as the network output. It reveals the model using obstacles, coins, enemies and more to compute the value function.
    </p>
    <d-figure style="grid-column: page; margin-bottom: 3em;">
      <figure>
        <div id="interface-header-target"></div>
      </figure>
    </d-figure>
    <h3 id="dissecting-failure">Dissecting failure</h3>
    <p>
      Our fully-trained model fails to complete around 1 in every 200 levels. We explored a few of these failures using our interface, and found that we were usually able to understand why they occurred.
    </p>
    <p>
      The failure often boils down to the fact that the model has no memory, and must therefore choose its action based only on the current observation. It is also common for some unlucky sampling of actions from the agent's policy to be partly responsible.
    </p>
    <p>
      Here are some cherry-picked examples of failures, carefully analyzed step-by-step.
    </p>
    <table style="margin-top: 1em; margin-bottom: 1em;">
      <tr>
        <td style="width: 50%; vertical-align: top;">
          <label id="interface-failure-obscured-label" style="color: black;">
            <b><input type="radio" name="interface-failure-options" checked id="interface-failure-obscured-option"> Buzzsaw obstacle obscured by enemy</b>
          </label><br>
          <label id="interface-failure-down-label" style="color: lightgray;">
            <b><input type="radio" name="interface-failure-options" id="interface-failure-down-option"> Stepping down to avoid jumping</b>
          </label><br>
          <label id="interface-failure-offscreen-label" style="color: lightgray;">
            <b><input type="radio" name="interface-failure-options" id="interface-failure-offscreen-option"> Landing platform moving off-screen</b>
          </label>
        </td>
        <td style="vertical-align: top;">
          <div style="min-height: 7.5em;">
            <div style="display: block;" id="interface-failure-obscured-text">
              The agent moves too far to the right while in mid-air as a result of a buzzsaw obstacle being temporarily hidden from view by a moving enemy. The buzzsaw comes back into view, but too late to avoid a collision.
            </div>
            <div style="display: none;" id="interface-failure-down-text">
              The agent presses down in a bid to delay a jump. This causes the agent to inadvertently step down from a box and onto an enemy.
            </div>
            <div style="display: none;" id="interface-failure-offscreen-text">
              The agent fails to move far enough to the right while in mid-air, as a result of the platform where it was intending to land moving below the field of view.
            </div>
          </div>
        </td>
      </tr>
    </table>
    <table style="grid-column: page; margin: 0em 2em;">
      <tr>
        <td style="width: 11.5em; white-space: nowrap; vertical-align: top; text-align: center;">
          <div style="display: inline-block;">
            <button id="interface-failure-previous" class="interface-failure-step-button">Prev</button><br>
            <button id="interface-failure-start" class="interface-failure-step-button">Start</button>
          </div>
          <button id="interface-failure-play-pause-button" class="play-pause-button">
            <span id="interface-failure-play-pause-span">&#9658;</span>
          </button>
          <div style="display: inline-block;">
            <button id="interface-failure-next" class="interface-failure-step-button">Next</button><br>
            <button id="interface-failure-end" class="interface-failure-step-button">End</button>
          </div>
          <br>
          <span id="interface-failure-position"></span>
        </td>
        <td style="vertical-align: top;">
          <div id="interface-failure-description" style="position: relative; height: 115px;"></div>
        </td>
      </tr>
    </table>
    <d-figure style="grid-column: page; margin-top: 1em;">
      <figure>
        <div id="interface-failure-obscured-target" style="display: block;"></div>
        <div id="interface-failure-down-target" style="display: none;"></div>
        <div id="interface-failure-offscreen-target" style="display: none;"></div>
      </figure>
    </d-figure>
    <h3 id="hallucinations">Hallucinations</h3>
    <p>
      We searched for errors in the model using generalized advantage estimation (GAE) <d-cite key="gae"></d-cite>,<d-footnote>We use the same GAE hyperparameters as in training, namely <d-math>\gamma=0.999</d-math> and <d-math>\lambda=0.95</d-math>.</d-footnote> which measures how successful each action turned out relative to the agent's expectations. An unusually high or low GAE indicates that either something unexpected occurred, or the agent's expectations were miscalibrated. Filtering for such timesteps can therefore find problems with the value function or policy.
    </p>
    <p>
      Using our interface, we found a couple of cases in which the model "hallucinated" a feature not present in the observation, causing the value function to spike.
    </p>
    <table style="margin-top: 1em; margin-bottom: 0em;">
      <tr>
        <td style="width: 30%; vertical-align: top;">
          <label id="interface-bug-coin-label" style="color: black;">
            <b><input type="radio" name="interface-bug-options" id="interface-bug-coin-option" checked> Coin hallucination</b>
          </label><br>
          <label id="interface-bug-saw-label" style="color: lightgray;">
            <b><input type="radio" name="interface-bug-options" id="interface-bug-saw-option"> Buzzsaw hallucination</b>
          </label>
        </td>
        <td style="vertical-align: top;">
          <div>
            <div style="display: block;" id="interface-bug-coin-text">
              At one point the value function spiked upwards from 95% to 98% for a single timestep. This was due to a curved yellow-brown shape in the background, which happened to appear next to a wall, being mistaken for a coin.
            </div>
            <div style="display: none;" id="interface-bug-saw-text">
              At another point the value function spiked downwards from 94% to 85% for a single timestep. This was due to the agent, colored in gray-blue and crouching against a mottled background, being mistaken for a buzzsaw obstacle. An actual buzzsaw was also present in the observation, but the main effect was from the misjudged agent, as shown by the larger red circle around the agent (hover over the first legend item to isolate).
            </div>
          </div>
        </td>
      </tr>
    </table>
    <d-figure style="grid-column: page; margin-top: 1em;">
      <figure>
        <div id="interface-bug-coin-target" style="display: block;"></div>
        <div id="interface-bug-saw-target" style="display: none;"></div>
      </figure>
    </d-figure>
    <h3 id="model-editing">Model editing</h3>
    <p>
      Our analysis so far has been mostly qualitative. To quantitatively validate our analysis, we hand-edited the model to make the agent blind to certain features identified by our interface: buzzsaw obstacles in one case, and left-moving enemies in another. Our method for this can be thought of as a primitive form of <a href="https://distill.pub/2020/circuits/">circuit</a>-editing <d-cite key="circuits"></d-cite>, and we explain it in detail in <a href="#model-editing-method">Appendix A</a>.
    </p>
    <p>
      We evaluated each edit by measuring the percentage of levels that the new agent failed to complete, broken down by the object that the agent collided with to cause the failure. Our results show that our edits were successful and targeted, with no statistically measurable effects on the agent's other abilities.<d-footnote>The data for this plot are as follows.<br>Percentage of levels failed due to: buzzsaw obstacle / enemy moving left / enemy moving right / multiple or other:<br>- Original model: 0.37% / 0.16% / 0.12% / 0.08%<br>- Buzzsaw obstacle blindness: 12.76% / 0.16% / 0.08% / 0.05%<br>- Enemy moving left blindness: 0.36% / 4.69% / 0.97% / 0.07%<br>Each model was tested on 10,000 levels.</d-footnote>
    </p>
    <figure class="matplotlib-svg" style="text-align: center;">
      <%= require("../static/diagrams/model_editing_results.svg") %>
      <figcaption>Results of testing each model on 10,000 levels. Note that moving enemies can change direction.</figcaption>
    </figure>
    <p>
      We did not manage to achieve complete blindness, however: the buzzsaw-edited model still performed significantly better than the original model did when we made the buzzsaws completely invisible.<d-footnote>Our results on the version of the game with invisible buzzsaws are as follows.<br>Percentage of levels failed due to: buzzsaw obstacle / enemy moving left / enemy moving right / multiple or other:<br>Original model, invisible buzzsaws: 32.20% / 0.05% / 0.05% / 0.05%<br>We tested the model on 10,000 levels.<br>We experimented briefly with iterating the editing procedure, but were not able to achieve more than around 50% buzzsaw blindness by this metric without affecting the model's other abilities.</d-footnote> This implies that the model has other ways of detecting buzzsaws than the feature identified by our interface.
    </p>
    <p>
      Here are the original and edited models playing some cherry-picked levels.
    </p>
    <figure id="model-editing-levels" style="grid-column: page;">
      <table>
        <tr>
          <td style="vertical-align: top;">
            <label id="model-editing-level-1-label" style="color: black;">
              <b><input type="radio" name="model-editing-level-options" checked id="model-editing-level-1-option"> Level 1</b>
            </label><br>
            <label id="model-editing-level-2-label" style="color: lightgray;">
              <b><input type="radio" name="model-editing-level-options" id="model-editing-level-2-option"> Level 2</b>
            </label><br>
            <label id="model-editing-level-3-label" style="color: lightgray;">
              <b><input type="radio" name="model-editing-level-options" id="model-editing-level-3-option"> Level 3</b>
            </label>
            <div style="margin-top: 1em;">
              <button id="model-editing-level-1-play-pause-button" class="play-pause-button" style="display: block; margin: 0 auto;">
                <span id="model-editing-level-1-play-pause-span">&#9658;</span>
              </button>
              <button id="model-editing-level-2-play-pause-button" class="play-pause-button" style="display: none; margin: 0 auto;">
                <span id="model-editing-level-2-play-pause-span">&#9658;</span>
              </button>
              <button id="model-editing-level-3-play-pause-button" class="play-pause-button" style="display: none; margin: 0 auto;">
                <span id="model-editing-level-3-play-pause-span">&#9658;</span>
              </button>
            </div>
          </td>
          <td>
            <div style="display: block;" id="model-editing-level-1-target-1">
              <video id="model-editing-level-1-video-1" controls muted>
                <source src="videos/model_editing/original_episode_0.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-2-target-1">
              <video id="model-editing-level-2-video-1" controls muted>
                <source src="videos/model_editing/original_episode_1.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-3-target-1">
              <video id="model-editing-level-3-video-1" controls muted>
                <source src="videos/model_editing/original_episode_2.mp4" type="video/mp4">
              </video>
            </div>
          </td>
          <td>
            <div style="display: block;" id="model-editing-level-1-target-2">
              <video id="model-editing-level-1-video-2" controls muted>
                <source src="videos/model_editing/saw_episode_0.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-2-target-2">
              <video id="model-editing-level-2-video-2" controls muted>
                <source src="videos/model_editing/saw_episode_1.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-3-target-2">
              <video id="model-editing-level-3-video-2" controls muted>
                <source src="videos/model_editing/saw_episode_2.mp4" type="video/mp4">
              </video>
            </div>
          </td>
          <td>
            <div style="display: block;" id="model-editing-level-1-target-3">
              <video id="model-editing-level-1-video-3" controls muted>
                <source src="videos/model_editing/enemy_episode_0.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-2-target-3">
              <video id="model-editing-level-2-video-3" controls muted>
                <source src="videos/model_editing/enemy_episode_1.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-3-target-3">
              <video id="model-editing-level-3-video-3" controls muted>
                <source src="videos/model_editing/enemy_episode_2.mp4" type="video/mp4">
              </video>
            </div>
          </td>
        </tr>
        <tr>
          <td></td>
          <td><figcaption>Original model.</figcaption></td>
          <td><figcaption>Buzzsaw obstacle blindness.</figcaption></td>
          <td><figcaption>Enemy moving left blindness.</figcaption></td>
        </tr>
      </table>
    </figure>
    <h2 id="diversity-hypothesis">The diversity hypothesis</h2>
    <p>
      All of the above analysis uses the same hidden layer of our network, the third of five convolutional layers, since it was much harder to find interpretable features at other layers. Interestingly, the level of abstraction at which this layer operates &ndash; finding the locations of various in-game objects &ndash; is exactly the level at which CoinRun levels are randomized using procedural generation. Furthermore, we found that training on many randomized levels was essential for us to be able to find any interpretable features at all.
    </p>
    <p>
      This led us to suspect that the diversity introduced by CoinRun's randomization is linked to the formation of interpretable features. We call this the <span style="font-style: italic;">diversity hypothesis</span>:
    </p>
    <blockquote>
      Interpretable features tend to arise (at a given level of abstraction) if and only if the training distribution is diverse enough (at that level of abstraction).
    </blockquote>
    <p>
      Our explanation for this hypothesis is as follows. For the forward implication ("only if"), we only expect features to be interpretable if they are general enough, and when the training distribution is not diverse enough, models have no incentive to develop features that generalize instead of overfitting. For the reverse implication ("if"), we do not expect it to hold in a strict sense: diversity on its own is not enough to guarantee the development of interpretable features, since they must also be relevant to the task. Rather, our intention with the reverse implication is to hypothesize that it holds very often in practice, as a result of generalization being bottlenecked by diversity.
    </p>
    <p>
      In CoinRun, procedural generation is used to incentivize the model to learn skills that generalize to unseen levels <d-cite key="procgen,gvgai,obstacletower"></d-cite>. However, only the <span style="font-style: italic;">layout</span> of each level is randomized, and correspondingly, we were only able to find interpretable features at the level of abstraction of objects. At a lower level, there are only a handful of visual patterns in the game, and the low-level features of our model seem to consist mostly of memorized color configurations used for picking these out. Similarly, the game's high-level dynamics follow a few simple rules, and accordingly the high-level features of our model seem to involve mixtures of combinations of objects that are hard to decipher. To explore the other convolutional layers, see the interface <a href="https://openaipublic.blob.core.windows.net/rl-clarity/attribution/demo/interface.html">here</a>.
    </p>
    <h3 id="interpretability-and-generalization">Interpretability and generalization</h3>
    <p>
      To test our hypothesis, we made the training distribution less diverse, by training the agent on a fixed set of 100 levels. This dramatically reduced our ability to interpret the model's features. Here we display an interface for the new model, generated in the same way as the one <a href="#interface">above</a>. The smoothly increasing value function suggests that the model has memorized the number of timesteps until the end of the level, and the features it uses for this focus on irrelevant background objects. Similar overfitting occurs for other video games with a limited number of levels <d-cite key="sonicsaliency"></d-cite>.
    </p>
    <d-figure style="grid-column: page; margin-bottom: 3em;">
      <figure>
        <div id="interface-100-levels-target"></div>
      </figure>
    </d-figure>
    <p>
      We attempted to quantify this effect by varying the number of levels used to train the agent, and evaluating the 8 features identified by our interface on how interpretable they were.<d-footnote>The interfaces used for this evaluation can be found <a href="https://openaipublic.blob.core.windows.net/rl-clarity/attribution/finite_levels/index.html">here</a>.</d-footnote> Features were scored based on how consistently they focused on the same objects, and whether the value function attribution made sense &ndash; for example, background objects should not be relevant. This process was subjective and noisy, but that may be unavoidable. We also measured the generalization ability of each model, by testing the agent on unseen levels <d-cite key="coinrunpaper"></d-cite>.<d-footnote>The data for this plot are as follows.<br>- Number of training levels: 100 / 300 / 1000 / 3,000 / 10,000 / 30,000 / 100,000<br>- Percentage of levels completed (train, run 1): 99.96% / 99.82% / 99.67% / 99.65% / 99.47% / 99.55% / 99.57%<br>- Percentage of levels completed (train, run 2): 99.97% / 99.86% / 99.70% / 99.46% / 99.39% / 99.50% / 99.37%<br>- Percentage of levels completed (test, run 1): 61.81% / 66.95% / 74.93% / 89.87% / 97.53% / 98.66% / 99.25%<br>- Percentage of levels completed (test, run 2): 64.13% / 67.64% / 73.46% / 90.36% / 97.44% / 98.89% / 99.35%<br>- Percentage of features interpretable (researcher 1, run 1): 52.5% / 22.5% / 11.25% / 45% / 90% / 75% / 91.25%<br>- Percentage of features interpretable (researcher 2, run 1): 8.75% / 8.75% / 10% / 26.25% / 56.25% / 90% / 70%<br>- Percentage of features interpretable (researcher 1, run 2): 15% / 13.75% / 15% / 23.75% / 53.75% / 90% / 96.25%<br>- Percentage of features interpretable (researcher 2, run 2): 3.75% / 6.25% / 21.25% / 45% / 72.5% / 83.75% / 77.5%<br>Percentages of levels completed are estimated by sampling 10,000 levels with replacement.</d-footnote>
    </p>
    <figure class="matplotlib-svg">
      <%= require("../static/diagrams/generalization_results.svg") %>
      <figcaption>Comparison of models trained on different numbers of levels. Two models were trained for each number of levels, and two researchers independently evaluated how interpretable the features of each model were, without being shown the number of levels.<d-footnote>Our methodology had some flaws. Firstly, the researchers were not completely blind to the number of levels: for example, it is possible to infer something about the number of levels from the smoothness of graphs of the value function, since with fewer levels the model is better able to memorize the number of timesteps until the end of the level. Secondly, since evaluations are somewhat tedious, we stopped them once we thought the trend had become clear, introducing some selection bias. Therefore these results should be considered primarily illustrative.</d-footnote> Each model was tested on 10,000 train and 10,000 test levels sampled with replacement. Shaded areas in the left plot show the range of values over both models, though these are mostly too narrow to be visible. Error bars in the right plot show &plusmn;1 population standard deviation over all four model&ndash;researcher pairs.</figcaption>
    </figure>
    <p>
      Our results illustrate how diversity may lead to interpretable features via generalization, lending support to the diversity hypothesis. Nevertheless, we still consider the hypothesis to be highly unproven.
    </p>
    <h2 id="feature-visualization">Feature visualization</h2>
    <p>
      <a href="https://distill.pub/2017/feature-visualization/">Feature visualization</a> <d-cite key="attribution1,featurevis,featurevis1,featurevis2,featurevis3,featurevis4"></d-cite> answers questions about what certain parts of a networkâ€‰are looking for by generating examples. This can be done by applying gradient descent to the input image, starting from random noise, with the objective of activating a particular neuron or group of neurons. While this method works well for an image classifier trained on ImageNet <d-cite key="imagenet"></d-cite>, for our CoinRun model it yields only featureless clouds of color. Only for the first layer, which computes simple convolutions of the input, does the method produce comparable visualizations for the two models.
    </p>
    <figure style="grid-column: page;">
      <div style="display: table; margin: 0 auto;">
        <table id="feature-vis-traditional">
          <tr><th></th><th>ImageNet</th><th>CoinRun</th></tr>
          <tr>
            <td>
              First layer
            </td>
            <td>
              <img src="images/feature_vis_traditional/imagenet_first_0.png">
              <img src="images/feature_vis_traditional/imagenet_first_1.png">
              <img src="images/feature_vis_traditional/imagenet_first_2.png">
            </td>
            <td>
              <img src="images/feature_vis_traditional/coinrun_first_0.png">
              <img src="images/feature_vis_traditional/coinrun_first_1.png">
              <img src="images/feature_vis_traditional/coinrun_first_2.png">
            </td>
          </tr>
          <tr>
            <td style="width: 1%;">
              Intermediate layer
            </td>
            <td>
              <img src="images/feature_vis_traditional/imagenet_intermediate_0.png">
              <img src="images/feature_vis_traditional/imagenet_intermediate_1.png">
              <img src="images/feature_vis_traditional/imagenet_intermediate_2.png">
            </td>
            <td>
              <img src="images/feature_vis_traditional/coinrun_intermediate_0.png">
              <img src="images/feature_vis_traditional/coinrun_intermediate_1.png">
              <img src="images/feature_vis_traditional/coinrun_intermediate_2.png">
            </td>
          </tr>
        </table>
        <figcaption style="display: table-caption; caption-side: bottom;">Comparison of gradient-based feature visualization for CNNs trained on ImageNet (GoogLeNet <d-cite key="googlenet"></d-cite>) and on CoinRun (architecture described <a href="#architecture">below</a>). Each image was chosen to activate a neuron in the center, with the 3 images corresponding to the first 3 channels. Jittering was applied between optimization steps of up to 2 pixels for the first layer, and up to 8 pixels for the intermediate layer (mixed4a for ImageNet, <a href="#architecture">2b</a> for CoinRun).</figcaption>
      </div>
    </figure>
    <p>
      Gradient-based feature visualization has previously been shown to struggle with RL models trained on Atari games <d-cite key="atarimodelzoo,atarifeaturevis"></d-cite>. To try to get it to work for CoinRun, we varied the method in a number of ways. Nothing we tried had any noticeable effect on the quality of the visualizations.
    </p>
    <ul>
      <li><b>Transformation robustness.</b> This is the method of stochastically jittering, rotating and scaling the image between optimization steps, to search for examples that are robust to these transformations <d-cite key="featurevis"></d-cite>. We tried both increasing and decreasing the size of the jittering. Rotating and scaling are less appropriate for CoinRun, since the observations themselves are not invariant to these transformations.</li>
      <li id="extremal-colors"><b>Penalizing extremal colors.</b><d-footnote>By an "extremal" color we mean one of the 8 colors with maximal or minimal RGB values (black, white, red, green, blue, yellow, cyan and magenta).</d-footnote> Noticing that our visualizations tend to use extremal colors towards the middle, we tried including in the visualization objective an L2 penalty of various strengths on the activations of the first layer, which successfully reduced the size of the extremally-colored region but did not otherwise help.</li>
      <li><b>Alternative objectives.</b> We tried using an alternative optimization objective <d-cite key="featurevis"></d-cite>, such as the caricature objective.<d-footnote>The caricature objective is to maximize the dot product between the activations of the input image and the activations of a reference image. Caricatures are often an especially easy type of feature visualization to make work, and helpful for getting a first glance into what features a model has. They are demonstrated in <a href="https://colab.research.google.com/github/tensorflow/lucid/blob/master/notebooks/misc/feature_inversion_caricatures.ipynb">this notebook</a>. A more detailed manuscript by its authors <d-cite key="caricatures"></d-cite> is forthcoming.</d-footnote> We also tried using dimensionality reduction, as described <a href="#dataset-examples">below</a>, to choose non-axis-aligned directions in activation space to maximize.
      <li><b>Low-level visual diversity.</b> In an attempt to broaden the distribution of images seen by the model, we retrained it on a version of the game with procedurally-generated sprites. We additionally tried adding noise to the images, both independent per-pixel noise and spatially-correlated noise. Finally, we experimented briefly with adversarial training <d-cite key="adversarialtraining"></d-cite>, though we did not pursue this line of inquiry very far.</li>
    </ul>
    <p id="feature-visualization-discussion">
      As shown <a href="#dataset-examples">below</a>, we were able to use dataset examples to identify a number of channels that pick out human-interpretable features. It is therefore striking how resistant gradient-based methods were to our efforts. We believe that this is because solving CoinRun does not ultimately require much visual ability. Even with our modifications, it is possible to solve the game using simple visual shortcuts, such as picking out certain small configurations of pixels. These shortcuts work well on the narrow distribution of images on which the model is trained, but behave unpredictably in the full space of images in which gradient-based optimization takes place.
    </p>
    <p>
      Our analysis here provides further insight into the <a href="#diversity-hypothesis">diversity hypothesis</a>. In support of the hypothesis, we have examples of features that are hard to interpret in the absence of diversity. But there is also evidence that the hypothesis may need to be refined. Firstly, it seems to be a lack of diversity at a low level of abstraction that harms our ability to interpret features at all levels of abstraction, which could be due to the fact that gradient-based feature visualization needs to back-propagate through earlier layers. Secondly, the failure of our efforts to increase low-level visual diversity suggests that diversity may need to be assessed in the context of the requirements of the task.
    </p>
    <h3 id="dataset-examples">Dataset example-based feature visualization</h3>
    <p>
      As an alternative to gradient-based feature visualization, we use dataset examples. This idea has a long history, and can be thought of as a heavily-regularized form of feature visualization <d-cite key="featurevis,featurevisadversarial"></d-cite>. In more detail, we sample a few thousand observations infrequently from the agent playing the game, and pass them through the model. We then apply a dimensionality reduction method known as non-negative matrix factorization (NMF) to the activation channels <d-cite key="buildingblocks"></d-cite>.<d-footnote>More precisely, we find a non-negative approximate low-rank factorization of the matrix obtained by flattening the spatial dimensions of the activations into the batch dimension. This matrix has one row per observation <i>per spatial position</i> and one column per channel: thus the dimensionality reduction does not use spatial information.</d-footnote> For each of the resulting channels (which correspond to weighted combinations of the original channels), we choose the observations and spatial positions with the strongest activation (with a limited number of examples per position, for diversity), and display a patch from the observation at that position.
    </p>
    <figure>
      <div id="feature-vis-dataset">
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_0.png"><div class="feature-vis-dataset-text">Short left-facing wall</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_1.png"><div class="feature-vis-dataset-text">Velocity info or left edge of screen</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_2.png"><div class="feature-vis-dataset-text">Long left-facing wall</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_3.png"><div class="feature-vis-dataset-text">Left end of platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_4.png"><div class="feature-vis-dataset-text">Right end of platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_5.png"><div class="feature-vis-dataset-text">Buzzsaw obstacle or platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_6.png"><div class="feature-vis-dataset-text">Coin</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_7.png"><div class="feature-vis-dataset-text">Top/right edge of screen</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_8.png"><div class="feature-vis-dataset-text">Left end of platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_9.png"><div class="feature-vis-dataset-text">Step</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_10.png"><div class="feature-vis-dataset-text">Agent or enemy moving right</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_11.png"><div class="feature-vis-dataset-text">Left edge of box</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_12.png"><div class="feature-vis-dataset-text">Right end of platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_13.png"><div class="feature-vis-dataset-text">Buzzsaw obstacle</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_14.png"><div class="feature-vis-dataset-text">Top left corner of box</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_15.png"><div class="feature-vis-dataset-text">Left end of platform or bottom/right of screen?</div></div>
      </div>
      <figcaption>Dataset example-based feature visualizations for 16 NMF directions of layer <a href="#architecture">2b</a> of our CoinRun model. The grey-white checkerboard represents the edge of the screen. The labels are hand-composed.</figcaption>
    </figure>
    <p>
      Unlike gradient-based feature visualization, this method finds some meaning to the different directions in activation space. However, it may still fail to provide a complete picture for each direction, since it only shows a limited number of dataset examples, and with limited context.
    </p>
    <h3 id="feature-visualization-spatial">Spatially-aware feature visualization</h3>
    <p>
      CoinRun observations differ from natural images in that they are much less spatially invariant. For example, the agent always appears in the center, and the agent's velocity is always encoded in the top left. As a result, some features detect unrelated things at different spatial positions, such as reading the agent's velocity in the top left while detecting an unrelated object elsewhere. To account for this, we developed a spatially-aware version of dataset example-based feature visualization, in which we fix each spatial position in turn, and choose the observation with the strongest activation at that position (with a limited number of reuses of the same observation, for diversity). This creates a spatial correspondence between visualizations and observations.
    </p>
    <p>
      Here is such a visualization for a feature that responds strongly to coins. The white squares in the top left show that the feature also responds strongly to the horizontal velocity info when it is white, corresponding to the agent moving right at full speed.
    </p>
    <figure>
      <div id="feature-vis-spatial" class="striped">
        <img src="images/feature_vis_spatial.png">
      </div>
      <figcaption>Spatially-aware dataset example-based feature visualization for the coin-detecting NMF direction of layer <a href="#architecture">2b</a>. Transparency (revealing the diagonally-striped background) indicates a weak response, so the left half of the visualization is mostly transparent because coins never appear in the left half of observations.</figcaption>
    </figure>
    <h2 id="attribution">Attribution</h2>
    <p>
      Attribution <d-cite key="attribution1,attribution2,attribution3,gradcam,attribution4,attribution5,attribution6,integratedgradients"></d-cite> answers questions about the relationships between neurons. It is most commonly used to see how the input to a network affects a particular output <d-cite key="perturbationsaliency"></d-cite>, but it can also be applied to the activations of hidden layers <d-cite key="buildingblocks"></d-cite>. Although there are many approaches to attribution we could have used, we chose the method of integrated gradients <d-cite key="integratedgradients"></d-cite>. We explain in <a href="#integrated-gradients">Appendix B</a> how we applied this method a hidden layer, and how positive value function attribution can be thought of as "good news" and negative value function attribution can as "bad news".
    </p>
    <h3 id="dimensionality-reduction">Dimensionality reduction for attribution</h3>
    <p>
      We showed <a href="#dataset-examples">above</a> that a dimensionality reduction method known as non-negative matrix factorization (NMF) could be applied to the channels of activations to produce meaningful directions in activation space <d-cite key="buildingblocks"></d-cite>. We found that it is even more effective to apply NMF not to activations, but to <span style="font-style: italic;">value function attributions</span><d-footnote>As before, we obtain the NMF directions by sampling a few thousand observations infrequently from the agent playing the game, computing the attributions, flattening the spatial dimensions into the batch dimension, and applying NMF.</d-footnote> (working around the fact that NMF can only be applied to non-negative matrices<d-footnote>Our workaround is to separate out the positive and negative parts of the attributions and concatenate them along the batch dimension. We could also have concatenated them along the channel dimension.</d-footnote>). Both methods tend to produce NMF directions that are close to one-hot, and so can be thought of as picking out the most relevant channels. However, when reducing to a small number of dimensions, using attributions usually picks out more salient features, because attribution takes into account not just <span style="font-style: italic;">what neurons respond to</span> but also <span style="font-style: italic;">whether their response matters</span>.
    </p>
    <p>
      Following <d-cite key="buildingblocks"></d-cite>, after applying NMF to attributions, we visualize them by assigning a different color to each of the resulting channels. We overlay these visualizations over the observation <d-cite key="gradcam"></d-cite> and contextualize each channel using feature visualization <d-cite key="buildingblocks"></d-cite>, making use of <a href="#dataset-examples">dataset example-based feature visualization</a>. This gives a basic version of our interface, which allows us to see the effect of the main features at different spatial positions.
    </p>
    <figure style="grid-column: page;">
      <div id="attribution-demo" style="display: table; margin: 0 auto; width: 100%;">
        <table style="margin-bottom: 1em; width: 100%;">
          <tr><th>Observation</th><th>Positive attribution <span style="font-weight: normal;">(good news)</span></th><th>Negative attribution <span style="font-weight: normal;">(bad news)</span></th></tr>
          <tr>
            <td>
              <div class="attribution-outer">
                <div class="attribution-inner" style="z-index: 0;">
                  <div class="attribution-image" style="background-image: url('images/attribution/observation.png');"></div>
                </div>
              </div>
            </td>
            <td>
              <div class="attribution-outer">
                <div class="attribution-inner" style="z-index: 0;">
                  <div class="attribution-image grayscale-dark" style="background-image: url('images/attribution/observation.png');"></div>
                </div>
                <div class="attribution-inner" style="z-index: 1;">
                  <div id="attribution-overlay-pos" class="attribution-image" style="background-image: url('images/attribution/attribution_pos.png');"></div>
                </div>
              </div>
            </td>
            <td>
              <div class="attribution-outer">
                <div class="attribution-inner" style="z-index: 0;">
                  <div class="attribution-image grayscale-dark" style="background-image: url('images/attribution/observation.png');"></div>
                </div>
                <div class="attribution-inner" style="z-index: 1;">
                  <div id="attribution-overlay-neg" class="attribution-image" style="background-image: url('images/attribution/attribution_neg.png');"></div>
                </div>
              </div>
            </td>
          </tr>
        </table>
        <div style="text-align: center; margin-bottom: 0.5em;">
          <span style="font-weight: bold; border-bottom: 1px solid lightgray;">Legend <span style="font-weight: normal;">(hover to isolate)</span></span>
          <br>
          <div id="attribution-legend-item-0" class="attribution-legend-item">
            <div class="attribution-legend-outer">
              <div class="attribution-legend-dot" style="background-color: #ff0000;"></div>
              <div class="attribution-legend-inner">
                <div class="attribution-image" style="background-image: url('images/attribution/layer_2b_feature_0.png');"></div>
              </div>
              <div class="attribution-legend-label">Buzzsaw<br>obstacle</div>
            </div>
          </div>
          <div id="attribution-legend-item-1" class="attribution-legend-item">
            <div class="attribution-legend-outer">
              <div class="attribution-legend-dot" style="background-color: #ffe400;"></div>
              <div class="attribution-legend-inner">
                <div class="attribution-image" style="background-image: url('images/attribution/layer_2b_feature_1.png');"></div>
              </div>
              <div class="attribution-legend-label">Coin</div>
            </div>
          </div>
          <div id="attribution-legend-item-2" class="attribution-legend-item">
            <div class="attribution-legend-outer">
              <div class="attribution-legend-dot" style="background-color: #a1ff00;"></div>
              <div class="attribution-legend-inner">
                <div class="attribution-image" style="background-image: url('images/attribution/layer_2b_feature_2.png');"></div>
              </div>
              <div class="attribution-legend-label">Enemy<br>moving<br>left</div>
            </div>
          </div>
          <div id="attribution-legend-item-3" class="attribution-legend-item">
            <div class="attribution-legend-outer">
              <div class="attribution-legend-dot" style="background-color: #00ffff;"></div>
              <div class="attribution-legend-inner">
                <div class="attribution-image" style="background-image: url('images/attribution/layer_2b_feature_3.png');"></div>
              </div>
              <div class="attribution-legend-label">Agent<br>or enemy<br>moving right</div>
            </div>
          </div>
        </div>
        <figcaption style="display: table-caption; caption-side: bottom;">
          Value function attribution for a cherry-picked observation using layer <a href="#architecture">2b</a> of our CoinRun model, reduced to 4 channels using attribution-based NMF. The dataset example-based feature visualizations of these directions reveal more salient features than the visualizations of the first 4 activation-based NMF directions from the preceding section.
        </figcaption>
      </div>
    </figure>
    <p>
      For the <a href="#interface">full version</a> of our interface, we simply repeat this for an entire trajectory of the agent playing the game. We also incorporate video controls, a timeline view of compressed observations <d-cite key="rmo"></d-cite>, and additional information, such as model outputs and sampled actions. Together these allow the trajectory to be easily explored and understood.
    </p>
    <h3 id="attribution-discussion">Attribution discussion</h3>
    <p>
      Attributions for our CoinRun model have some interesting properties that would be unusual for an ImageNet model.
    </p>
    <ul>
      <li><b>Sparsity.</b> Attribution tends to be concentrated in a very small number of spatial positions and (post-NMF) channels. For example, in the figure above, the top 10 position&ndash;channel pairs account for more than 80% of the total absolute attribution. This might be explained by our <a href="#feature-visualization-discussion">earlier</a> hypothesis that the model identifies objects by picking out certain small configurations of pixels. Because of this sparsity, we smooth out attribution over nearby spatial positions for the full version of our interface, so that the amount of visual space taken up can be used to judge attribution strength. This trades off some spatial precision for more precision with magnitudes.</li>
      <li><b>Unexpected sign.</b> Value function attribution usually has the sign one would expect: positive for coins, negative for enemies, and so on. However, this is sometimes not the case. For example, in the figure above, the red channel that detects buzzsaw obstacles has both positive and negative attribution in two neighboring spatial positions towards the left. Our best guess is that this phenomenon is a result of statistical <a href="https://en.wikipedia.org/wiki/Multicollinearity">collinearity</a>, caused by certain correlations in the procedural level generation together with the agent's behavior. These could be visual, such as correlations between nearby pixels, or more abstract, such as both coins and long walls appearing at the end of every level. As a toy example, supposing the value function ought to increase by 2% when the end of the level becomes visible, the model could either increase the value function by 1% for coins and 1% for long walls, or by 3% for coins and &minus;1% for long walls, and the effect would be similar.</li>
      <li><b>Outlier frames.</b> When an unusual event causes the network to output extreme values, attribution can behave especially strangely. For example, in the <a id="bug-saw-link" href="#hallucinations">buzzsaw hallucination</a> frame, most features have a significant amount of both positive and negative attribution. We do not have a good explanation for this, but perhaps features are interacting in more complicated ways than usual. Moreover, in these cases there is often a significant component of the attribution lying outside the space spanned by the NMF directions, which we display as an additional "residual" feature. This could be because each frame is weighted equally when computing NMF, so outlier frames have little influence over the NMF directions.</li>
    </ul>
    <p>
      These considerations suggest that some care may be required when interpreting attributions.
    </p>
    <h2 id="questions">Questions for further research</h2>
    <h3>The <a href="#diversity-hypothesis">diversity hypothesis</a></h3>
    <ol>
      <li><b>Validity.</b> Does the diversity hypothesis hold in other contexts, both within and outside of reinforcement learning?</li>
      <li><b>Relationship to generalization.</b> What is the three-way relationship between diversity, interpretable features and generalization? Do non-interpretable features indicate that a model will fail to generalize in certain ways? Generalization refers implicitly to an underlying distribution &ndash; how should this distribution be chosen?<d-footnote>For example, to measure generalization for CoinRun models trained on a limited number of levels, we used the distribution over all possible procedurally-generated levels. However, to formalize the sense in which CoinRun is not diverse in its visual patterns or dynamics rules, one would need a distribution over levels from a wider class of games.</d-footnote></li>
      <li><b>Caveats.</b> How are interpretable features affected by other factors, such as the choice of task or algorithm, and how do these interact with diversity? Speculatively, do big enough models obtain interpretable features via the double descent phenomenon <d-cite key="doubledescent"></d-cite>, even in the absence of diversity?</li>
      <li><b>Quantification.</b> Can we quantitatively predict how much diversity is needed for interpretable features, perhaps using generalization metrics? Can we be precise about what is meant by an "interpretable feature" and a "level of abstraction"?</li>
    </ol>
    <h3>Interpretability in the absence of diversity</h3>
    <ol>
      <li><b>Pervasiveness of non-diverse features.</b> Do "non-diverse features", by which we mean the hard-to-interpret features that tend to arise in the absence of diversity, remain when diversity is present? Is there a connection between these non-diverse features and the "non-robust features" that have been posited to explain adversarial examples <d-cite key="advexfeatures,advexfeaturesdiscussion"></d-cite>?</li>
      <li><b>Coping with non-diverse levels of abstraction.</b> Are there levels of abstraction at which even broad distributions like ImageNet remain non-diverse, and how can we best interpret models at these levels of abstraction?</li>
      <li><b>Gradient-based feature visualization.</b> Why does gradient-based feature visualization <a href="#feature-visualization">break down</a> in the absence of diversity, and can it be made to work using transformation robustness, regularization, data augmentation, adversarial training, or other techniques? What property of the optimization leads to the clouds of <a href="#extremal-colors">extremal colors</a>?</li>
      <li><b>Trustworthiness of dataset examples and attribution.</b> How reliable and trustworthy can we make very heavily-regularized versions of feature visualization, such as those based on <a href="#dataset-examples">dataset examples</a>?<d-footnote>Heavily-regularized feature visualization may be untrustworthy by failing to separate the things causing certain behavior from the things that merely correlate with those causes <d-cite key="featurevis"></d-cite>.</d-footnote> What explains the <a href="#attribution-discussion">strange behavior</a> of attribution, and how trustworthy is it?</li>
    </ol>
    <h3>Interpretability in the RL framework</h3>
    <ol>
      <li><b>Non-visual and abstract features.</b> What are the best methods for interpreting models with non-visual inputs? Even vision models may also have interpretable abstract features, such as relationships between objects or anticipated events: will any method of generating examples be enough to understand these, or do we need an entirely new approach? For models with memory, how can we interpret their hidden states <d-cite key="capturetheflag,rubik,dota"></d-cite>?</li>
      <li><b>Improving reliability.</b> How can we best identify, understand and correct rare <a href="#dissecting-failure">failures</a> and <a href="#hallucinations">other errors</a> in RL models? Can we actually improve models by <a href="#model-editing">model editing</a>, rather than merely degrading them?</li>
      <li><b>Modifying training.</b> In what ways can we train RL models to make them more interpretable without a significant performance cost, such as by altering architectures or adding auxiliary predictive losses?</li>
      <li><b>Leveraging the environment.</b> How can we enrich interfaces using RL-specific data, such as trajectories of agent&ndash;environment interaction, state distributions, and advantage estimates? What are the benefits of incorporating user&ndash;environment interaction, such as for exploring counterfactuals?</li>
    </ol>
    <h3 id="questions-discussion">What we would like to see from further research and why</h3>
    <p>
      We are motivated to study interpretability for RL for two reasons.
    </p>
    <ul>
      <li><b>To be able to interpret RL models.</b> RL can be applied to an enormous variety of tasks, and seems likely to be a part of increasingly influential AI systems. It is therefore important to be able to scrutinize RL models and to understand how they might fail. This may also benefit RL research through an improved understanding of the pitfalls of different algorithms and environments.</li>
      <li><b>As a testbed for interpretability techniques.</b> RL models pose a number of distinctive challenges for interpretability techniques. In particular, environments like CoinRun straddle the boundary between memorization and generalization, making them useful for studying the <a href="#diversity-hypothesis">diversity hypothesis</a> and related ideas.</li>
    </ul>
    <p>
      We think that large neural networks are currently the most likely type of model to be used in highly capable and influential AI systems in the future. Contrary to the traditional perception of neural networks as black boxes, we think that there is a fighting chance that we will be able to clearly and thoroughly understand the behavior even of very large networks. We are therefore most excited by neural network interpretability research that scores highly according to the following criteria.
    </p>
    <ul>
      <li><b>Scalability.</b> The takeaways of the research should have some chance of scaling to harder problems and larger networks. If the techniques themselves do not scale, they should at least reveal some relevant insight that might.</li>
      <li><b>Trustworthiness.</b> Explanations should be faithful to the model. Even if they do not tell the full story, they should at least not be biased in some fatal way (such as by using an approval-based objective that leads to bad explanations that sound good, or by depending on another model that badly distorts information).</li>
      <li><b>Exhaustiveness.</b> This may turn out to be impossible at scale, but we should strive for techniques that explain every essential feature of our models. If there are theoretical limits to exhaustiveness, we should try to understand these.</li>
      <li><b>Low cost.</b> Our techniques should not be significantly more computationally expensive than training the model. We hope that we will not need to train models differently for them to be interpretable, but if we do, we should try to minimize both the computational expense and any performance cost, so that interpretable models are not disincentivized from being used in practice.</li>
    </ul>
    <p>
      Our proposed questions reflect this perspective. One of the reasons we emphasize diversity relates to exhaustiveness. If "non-diverse features" remain when diversity is present, then our current techniques are not exhaustive and could end up missing important features of more capable models. Developing tools to understand non-diverse features may shed light on whether this is likely to be a problem.
    </p>
    <p>
      We think there may be significant mileage in simply applying existing interpretability techniques, with attention to detail, to more models. Indeed, this was the mindset with which we initially approached this project. If the diversity hypothesis is correct, then this may become easier as we train our models to perform more complex tasks. Like early biologists encountering a new species, there may be a lot we can glean from taking a magnifying glass to the creatures in front of us.
    </p>
    <h2 id="supplementary-material">Supplementary material</h2>
    <ul>
      <li><b>Code.</b> Utilities for computing feature visualization, attribution and dimensionality reduction for our models can be found in <code>lucid.scratch.rl_util</code>, a submodule of <a href="https://github.com/tensorflow/lucid">Lucid</a>. We demonstrate these in a <a href="https://colab.research.google.com/github/tensorflow/lucid/blob/master/notebooks/misc/rl_util.ipynb"><img src="images/colab.svg"> notebook</a>.</li>
      <li><b>Model weights.</b> The weights of our model are available for download, along with those of a number of other models, including the models trained on different numbers of levels, the edited models, and models trained on all 16 of the Procgen Benchmark <d-cite key="procgen"></d-cite> games. These are indexed <a href="https://openaipublic.blob.core.windows.net/rl-clarity/attribution/models/index.html">here</a>.</li>
      <li><b>More interfaces.</b> We generated an expanded version of our interface for every convolutional layer in our model, which can be found <a href="https://openaipublic.blob.core.windows.net/rl-clarity/attribution/demo/interface.html">here</a>. We also generated similar interfaces for each of our other models, which are indexed <a href="https://openaipublic.blob.core.windows.net/rl-clarity/attribution/index.html">here</a>.</li>
      <li><b>Interface code.</b> The code used to generate the expanded version of our interface can be found <a href="https://github.com/openai/understanding-rl-vision">here</a>.</li>
    </ul>

  </d-article>

  <d-appendix id="appendix">
    <h3 id="model-editing-method">Appendix A: Model editing method</h3>
    <p>
      Here we explain our method for <a href="#model-editing">editing the model</a> to make the agent blind to certain features.
    </p>
    <p>
      The features in our interface correspond to directions in activation space obtained by applying <a href="#dimensionality-reduction">attribution-based NMF</a> to layer <a href="#architecture">2b</a> of our model. To blind the agent to a feature, we edit the weights to make them project out the corresponding NMF direction.
    </p>
    <p>
      More precisely, let <d-math>\mathbf v</d-math> be the NMF direction corresponding to the feature we wish to blind the model to. This is a vector of length <d-math>c</d-math>, the number of channels in activation space. Using this we construct the <a href="https://en.wikipedia.org/wiki/Projection_(linear_algebra)">orthogonal projection</a> matrix <d-math>P:=I-\frac 1{\|\mathbf v\|^2}\mathbf v\mathbf v^{\mathsf T}</d-math>, which projects out the direction of <d-math>\mathbf v</d-math> from activation vectors. We then take the convolutional kernel of the following layer, which has shape <d-math>\text{height}\times\text{width}\times c\times d</d-math>, where <d-math>d</d-math> is the number of output channels. Broadcasting across the height and width dimensions, we left-multiply each <d-math>c\times d</d-math> matrix in the kernel by <d-math>P</d-math>. The effect of the new kernel is to project out the direction of <d-math>\mathbf v</d-math> from activations before applying the original kernel.
    </p>
    <p>
      As it turned out, the NMF directions were close to one-hot, so this procedure is approximately equivalent to zeroing out the slice of the kernel corresponding to a particular in-channel.
    </p>
    <h3 id="integrated-gradients">Appendix B: Integrated gradients for a hidden layer</h3>
    <p>
      Here we explain the application of integrated gradients <d-cite key="integratedgradients"></d-cite> to a hidden layer for the purpose of <a href="#attribution">attribution</a>. This method can be applied to any of the network's outputs, but we focus here on the value function. Recall that this is the model's estimate of the time-discounted probability that the agent will successfully complete the level.
    </p>
    <div>
      <div style="float: right;">
        <figure style="width: 300px; margin: 0.5em 0.5em 1em 1em;">
          <svg height="160px" width="300px">
            <defs>
              <marker id="arrow-factorization" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L0,6 L9,3 z" fill="#000000" />
              </marker>
            </defs>
            <line x1="100" y1="30" x2="210" y2="30" stroke="#000000" stroke-width="1" marker-end="url(#arrow-factorization)"></line>
            <line x1="80" y1="50" x2="110" y2="100" stroke="#000000" stroke-width="1" marker-end="url(#arrow-factorization)"></line>
            <line x1="190" y1="100" x2="220" y2="50" stroke="#000000" stroke-width="1" marker-end="url(#arrow-factorization)"></line>
            <text x="50" y="20" text-anchor="middle">observation</text>
            <text x="50" y="40" text-anchor="middle">space</text>
            <text x="230" y="35" text-anchor="middle" class="katex"><tspan class="mathbb">R</tspan></text>
            <text x="150" y="120" text-anchor="middle">activation</text>
            <text x="150" y="140" text-anchor="middle">space</text>
            <text x="155" y="20" text-anchor="middle" class="katex"><tspan class="mathit">V</tspan></text>
            <text x="80" y="90" text-anchor="middle" class="katex"><tspan class="mathbf">A</tspan></text>
            <text x="220" y="90" text-anchor="middle" class="katex"><tspan class="mathit">F</tspan></text>
          </svg>
          <figcaption>The <a href="https://en.wikipedia.org/wiki/Commutative_diagram">diagram</a> defining <d-math>F</d-math>, whose gradient we take.</figcaption>
        </figure>
      </div>
      <p>
        Let <d-math>V:\mathbb R^{64\times 64\times 3}\to\mathbb R</d-math> be the value function computed by our network, which accepts a 64x64 RGB observation. Given any layer in the network, we may write <d-math>V</d-math> as <d-math>V\left(\mathbf x\right)=F\left(\mathbf A\left(\mathbf x\right)\right)</d-math>, where <d-math>\mathbf A</d-math> computes the layer's activations. Given an observation <d-math>\mathbf x</d-math>, a simple method of attribution is to compute <d-math>\nabla_{\mathbf a}F\left(\mathbf a\right)\odot\mathbf a</d-math>, where <d-math>\mathbf a=\mathbf A\left(\mathbf x\right)</d-math> and <d-math>\odot</d-math> denotes the pointwise product. This tells us the sensitivity of the value function to each activation, multiplied by the strength of that activation. However, it uses the sensitivity of the value function at the activation itself, which does not account for the fact that this sensitivity may change as the activation is increased from zero.
      </p>
    </div>
    <div>
      <div style="float: right;">
        <figure style="width: 300px; margin: 0.5em 0.5em 1em 1em;">
          <img src="images/integrated_gradient.png">
          <figcaption>Viewing <d-math>F</d-math> as the height of a surface, represented here using the background gradient, the integrated gradient of <d-math>F</d-math> measures the elevation gained while traveling in each direction, and sums to the total elevation gain <d-cite key="attributionpaths"></d-cite>.</figcaption>
        </figure>
      </div>
      <p>
        To account for this, the integrated gradients method instead chooses a path <d-math>\mathcal P</d-math> in activation space from some starting point <d-math>\mathbf a_0</d-math> to the ending point <d-math>\mathbf a_1:=\mathbf A\left(\mathbf x\right)</d-math>. We then compute the integrated gradient of <d-math>F</d-math> along <d-math>\mathcal P</d-math>, which is defined as the path integral <d-math block="">\int_{\mathcal P}\nabla_{\mathbf a}F\left(\mathbf a\right)\odot\mathrm d\mathbf a.</d-math> Note the use of the pointwise product rather than the usual dot product here, which makes the integral vector-valued. By the <a href="https://en.wikipedia.org/wiki/Gradient_theorem">fundamental theorem of calculus for line integrals</a>, when the components of the vector produced by this integral are summed, the result depends only on the endpoints <d-math>\mathbf a_0</d-math> and <d-math>\mathbf a_1</d-math>, equaling <d-math>F\left(\mathbf a_1\right)-F\left(\mathbf a_0\right)</d-math>. Thus the components of this vector provide a true decomposition of this difference, "attributing" it across the activations.
      </p>
      <p style="margin-bottom: 0;">
        For our purposes, we take <d-math>\mathcal P</d-math> to be the straight line from <d-math>\mathbf 0</d-math> to <d-math>\mathbf A\left(\mathbf x\right)</d-math>.<d-footnote>In theory, we could choose any point in activation space as the starting point of our path, but in practice, <d-math>\mathbf 0</d-math> tends to be a good baseline against which to compare other activations, with <d-math>F\left(\mathbf 0\right)</d-math> being on the same order as the average value function. Sundararajan, Taly and Yan <d-cite key="integratedgradients"></d-cite> discuss the choice of this baseline in more depth.</d-footnote> In other words, given an observation <d-math>\mathbf x</d-math>, we define the value function attribution as<d-footnote>In practice, we numerically approximate the integral by evaluating the integrand at <d-math>\alpha=0.1,0.2,\ldots,1</d-math>.</d-footnote>
      </p>
      <d-math block="" style="margin: 0 auto;">
        \int_{\alpha=0}^1\nabla_{\mathbf a}F\left(\alpha\mathbf A\left(\mathbf x\right)\right)\mathrm d\alpha\odot\mathbf A\left(\mathbf x\right).
      </d-math>
      <p>
        This has the same dimensions as <d-math>\mathbf A\left(\mathbf x\right)</d-math>, and its components sum to <d-math>V\left(\mathbf x\right)-F\left(\mathbf 0\right)</d-math>. So for a convolutional layer, this method allows us to attribute the value function (in excess of the baseline <d-math>F\left(\mathbf 0\right)</d-math>) across the horizontal, vertical and channel dimensions of activation space. Positive value function attribution can be thought of as "good news", components that cause the agent to think it is more likely to collect the coin at the end of the level. Similarly, negative value function attribution can be thought of as "bad news".
      </p>
    </div>
    <h3 id="architecture">Appendix C: Architecture</h3>
    <p>
      Our architecture consists of the following layers in the order given, together with ReLU activations for all except the final layer.
    </p>
    <ul class="architecture-list">
      <li>7x7 convolutional layer with 16 channels (layer 1a)</li>
      <li>2x2 L2 pooling layer</li>
      <li>5x5 convolutional layer with 32 channels (layer 2a)</li>
      <li>5x5 convolutional layer with 32 channels (layer 2b)</li>
      <li>2x2 L2 pooling layer</li>
      <li>5x5 convolutional layer with 32 channels (layer 3a)</li>
      <li>2x2 L2 pooling layer</li>
      <li>5x5 convolutional layer with 32 channels (layer 4a)</li>
      <li>2x2 L2 pooling layer</li>
      <li>256-unit dense layer</li>
      <li>512-unit dense layer</li>
      <li>10-unit dense layer (1 unit for the value function, 9 units for the policy logits)</li>
    </ul>
    <p>
      We designed this architecture by starting with the architecture from IMPALA <d-cite key="impala"></d-cite>, and making the following modifications in an attempt to aid interpretability without noticeably sacrificing performance.
    </p>
    <ul class="architecture-list">
      <li>We used fewer convolutional layers and more dense layers, to allow for more non-visual processing.</li>
      <li>We removed the residual connections, so that the flow of information passes through every layer.</li>
      <li>We made the pool size equal to the pool stride, to avoid gradient gridding.</li>
      <li>We used L2 pooling instead of max pooling, for more continuous gradients.</li>
    </ul>
    <p>
      The choice that seemed to make the most difference was using 5 rather than 12 convolutional layers, resulting in the object-identifying features (which were the most interpretable, as discussed <a href="#diversity-hypothesis">above</a>) being concentrated in a single layer (layer 2b), rather than being spread over multiple layers and mixed in with less interpretable features.
    </p>
    <h3>Acknowledgments</h3>
    <p>
      We would like to thank our reviewers Jonathan Uesato, Joel Lehman and one anonymous reviewer for their detailed and thoughtful feedback. We would also like to thank Karl Cobbe, Daniel Filan, Sam Greydanus, Christopher Hesse, Jacob Jackson, Michael Littman, Ben Millwood, Konstantinos Mitsopoulos, Mira Murati, Jorge Orbay, Alex Ray, Ludwig Schubert, John Schulman, Ilya Sutskever, Nevan Wichers, Liang Zhang and Daniel Ziegler for research discussions, feedback, follow-up work, help and support that have greatly benefited this project.
    </p>

    <h3>Author contributions</h3>
    <p>
      <b>Jacob Hilton</b> was the primary contributor.
    </p>
    <p>
      <b>Nick Cammarata</b> developed the model editing methodology and suggested applying it to CoinRun models.
    </p>
    <p>
      <b>Shan Carter</b> (while working at OpenAI) advised on interface design throughout the project, and worked on many of the diagrams in the article.
    </p>
    <p>
      <b>Gabriel Goh</b> provided evaluations of feature interpretability for the section <a href="#interpretability-and-generalization">Interpretability and generalization</a>.
    </p>
    <p>
      <b>Chris Olah</b> guided the direction of the project, performing initial exploratory research on the models, coming up with many of the research ideas, and helping to construct the article's narrative.
    </p>

    <d-footnote-list></d-footnote-list>
    <d-citation-list></d-citation-list>
  </d-appendix>

  <d-bibliography src="bibliography.bib"></d-bibliography>

</body>
