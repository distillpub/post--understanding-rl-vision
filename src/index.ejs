<!doctype html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://distill.pub/template.v2.js"></script>
  <style>
    <%=require("raw-loader!../static/style.css").default %>
  </style>
</head>

<body>

  <d-front-matter>
    <script type="text/json">{
      "title": "Understanding RL vision",
      "description": "With a diverse environment, we can analyze, diagnose and edit deep reinforcement learning models using attribution.",
      "authors": [
        {
          "author": "Jacob Hilton",
          "authorURL": "https://www.jacobh.co.uk/",
          "affiliation": "OpenAI",
          "affiliationURL": "https://openai.com"
        },
        {
          "author": "Chris Olah",
          "authorURL": "https://colah.github.io/",
          "affiliation": "OpenAI",
          "affiliationURL": "https://openai.com"
        },
        {
          "author": "Author list not yet finalized.",
          "authorURL": "https://openai.com",
          "affiliation": "OpenAI",
          "affiliationURL": "https://openai.com"
        }
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  <d-title>
    <h1>Understanding RL vision</h1>
    <p>With a diverse environment, we can analyze, diagnose and edit deep reinforcement learning models using attribution.</p>
    <figure id="hero" style="margin-top: 1em; margin-bottom: 0.5em; width: 100%;">
      <table style="margin-bottom: 1.5em; width: 100%;">
        <tr>
          <th>
            Negative attribution <span style="font-weight: normal;">(bad news)</span>
            <br>
            <span class="hero-help">Color overlay shows objects predictive of failure</span>
          </th>
          <th>
            Observation
            <br>
            <span class="hero-help">Pixels from the video game</span>
          </th>
          <th>
            Positive attribution <span style="font-weight: normal;">(good news)</span>
            <br>
            <span class="hero-help">Color overlay shows objects predictive of success</span>
          </th>
        </tr>
        <tr>
          <td>
            <div class="hero-outer">
              <div class="hero-inner" style="z-index: 0;">
                <div class="hero-image" style="background-image: url('images/hero/observation_grayscale.png');"></div>
              </div>
              <div class="hero-inner" style="z-index: 1;">
                <div id="hero-overlay-neg" class="hero-image" style="background-image: url('images/hero/attribution_neg.png');"></div>
              </div>
            </div>
          </td>
          <td>
            <div class="hero-outer">
              <div class="hero-inner" style="z-index: 0;">
                <div id="hero-observation" class="hero-image" style="background-image: url('images/hero/observation.png');"></div>
              </div>
            </div>
          </td>
          <td>
            <div class="hero-outer">
              <div class="hero-inner" style="z-index: 0;">
                <div class="hero-image" style="background-image: url('images/hero/observation_grayscale.png');"></div>
              </div>
              <div class="hero-inner" style="z-index: 1;">
                <div id="hero-overlay-pos" class="hero-image" style="background-image: url('images/hero/attribution_pos.png');"></div>
              </div>
            </div>
          </td>
        </tr>
      </table>
      <div id="hero-annotations">
        <div><img id="hero-annotation-0" src="images/hero/saw.png" class="hero-annotation-image"><br>Buzzsaw</div>
        <div><img id="hero-annotation-2" src="images/hero/enemy.png" class="hero-annotation-image"><br>Enemy</div>
        <div><img id="hero-annotation-1" src="images/hero/coin.png" class="hero-annotation-image"><br>Coin</div>
      </div>
    </figure>
  </d-title>

  <d-article>

    <p id="introduction">
      In this article, we apply interpretability techniques to a reinforcement learning (RL) model trained to play the video game CoinRun <d-cite key="coinrunpaper"></d-cite>. Using attribution <d-cite key="attribution1,attribution2,attribution3,gradcam,attribution4,attribution5,attribution6,integratedgradients"></d-cite> and dimensionality reduction, we build an interface <d-cite key="buildingblocks"></d-cite> for exploring the objects detected by the model, and how they influence its value function and policy. We leverage this interface in several ways.
    </p>
    <ul>
      <li><b><a href="#dissecting-failure">Dissecting failure</a>.</b> We perform a step-by-step analysis of the agent's behavior in cases where it failed to achieve the maximum reward, allowing us to understand what went wrong, and why.</li>
      <li><b><a href="#error-diagnosis">Error diagnosis</a>.</b> We find situations when the model "hallucinated" a feature not present in the observation, thereby explaining inaccuracies in the model's value function.</li>
      <li><b><a href="#model-editing">Model editing</a>.</b> We hand-edit the weights of the model to blind the agent to certain hazards, without otherwise changing the agent's behavior. We verify this by checking which hazards cause the new agents to fail, quantitatively validating our analysis.</li>
    </ul>
    <p>
      Our results depend on levels in CoinRun being procedurally-generated, leading us to formulate a <span style="font-style: italic;"><a href="#diversity-hypothesis">diversity hypothesis</a></span> for interpretability. If it is correct, then we can expect RL models to become more interpretable as the environments they are trained on become more diverse. We provide evidence for our hypothesis by measuring the relationship between interpretability and generalization.
    </p>
    <p>
      Finally, we provide a thorough <a href="#feature-visualization">investigation</a> of several interpretability techniques in the context of RL vision, and pose a number of <a href="#questions">questions</a> for further research.
    </p>
    <h2 id="coinrun">Our CoinRun model</h2>
    <p>
      CoinRun is a side-scrolling platformer in which the agent must dodge enemies and other traps and collect the coin at the end of the level.
    </p>
    <figure>
      <video width="100%" autoplay loop>
        <source src="videos/coinrun.mp4" type="video/mp4">
      </video>
      <figcaption style="text-align: center;">Our trained model playing CoinRun. <b>Left</b>: full resolution. <b>Right</b>: 64x64 RGB observations given to the model.</figcaption>
    </figure>
    <p>
      CoinRun is procedurally-generated, meaning that each new level encountered by the agent is randomly generated from scratch. This incentivizes the model to learn how to spot the different kinds of objects in the game, since it is not enough to simply memorize a small number of specific trajectories <d-cite key="procgen"></d-cite>.<d-footnote>We use the original version of CoinRun <d-cite key="coinrunpaper"></d-cite>, not the version from Procgen Benchmark <d-cite key="procgen"></d-cite>, which is slightly different.</d-footnote>
    </p>
    <p>
      Here are some examples of the objects used, along with walls and floors, to generate CoinRun levels.
    </p>
    <figure id="coinrun-objects">
      <table>
        <tr class="coinrun-objects-row-images">
          <td style="font-weight: bold; white-space: normal;">Full resolution</td>
          <td>
            <img src="images/coinrun/agent_0_human.png" class="coinrun-object-double">
            <img src="images/coinrun/agent_1_human.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/coin_1_human.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/saw_1_human.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/enemy_0_human.png" class="coinrun-object-double">
            <img src="images/coinrun/enemy_1_human.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/box_0_human.png" class="coinrun-object-double">
            <img src="images/coinrun/box_1_human.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/lava_human.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/velocity_info_human.png" class="coinrun-object-single">
          </td>
        </tr>
        <tr class="coinrun-objects-row-images">
          <td style="font-weight: bold; white-space: normal;">Model resolution</td>
          <td>
            <img src="images/coinrun/agent_0_model.png" class="coinrun-object-double">
            <img src="images/coinrun/agent_1_model.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/coin_1_model.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/saw_1_model.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/enemy_0_model.png" class="coinrun-object-double">
            <img src="images/coinrun/enemy_1_model.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/box_0_model.png" class="coinrun-object-double">
            <img src="images/coinrun/box_1_model.png" class="coinrun-object-double">
          </td>
          <td>
            <img src="images/coinrun/lava_model.png" class="coinrun-object-single">
          </td>
          <td>
            <img src="images/coinrun/velocity_info_model.png" class="coinrun-object-single">
          </td>
        </tr>
        <tr class="coinrun-objects-row-text">
          <td></td>
          <td><figcaption>The agent, in mid air (left) and about to jump (right).</figcaption></td>
          <td><figcaption>Coins, which have to be collected.</figcaption></td>
          <td><figcaption>Stationary buzzsaw obstacles, which must be dodged.</figcaption></td>
          <td><figcaption>Enemies, which must be dodged, moving left (left) and right (right).</figcaption></td>
          <td><figcaption>Boxes, which the agent can both move past and land on top of.</figcaption></td>
          <td><figcaption>Lava at the bottom of a chasm.</figcaption></td>
          <td><figcaption>The velocity info painted into the top left of each observation, indicating the agent's horizontal and vertical velocities.<d-footnote class="velocity-info-footnote">The left square indicates the agent's horizontal velocity (black for left, white for right), and the right square indicates the agent's vertical velocity (black for down, white for up). In this example, the agent is moving forward and about to land.</d-footnote></figcaption></td>
        </tr>
      </table>
    </figure>
    <p>
      There are 9 actions available to the agent in CoinRun:
    </p>
    <figure id="coinrun-actions">
      <table>
        <tr>
          <td><span class="coinrun-action">&#8592;</span></td>
          <td><span class="coinrun-action">&#8594;</span></td>
          <td></td>
          <td><figcaption>Left and right change the agent's horizontal velocity. They still work while the agent is in mid-air, but have less of an effect.</figcaption></td>
        </tr>
        <tr>
          <td><span class="coinrun-action">&#8595;</span></td>
          <td></td>
          <td></td>
          <td><figcaption>Down cancels a jump if used immediately after up, and steps the agent down from boxes.</figcaption></td>
        </tr>
        <tr>
          <td><span class="coinrun-action">&#8593;</span></td>
          <td><span class="coinrun-action">&#8598;</span></td>
          <td><span class="coinrun-action">&#8599;</span></td>
          <td><figcaption>Up causes the agent to jump after the next non-up action. Diagonal directions have the same effect as both component directions combined.</figcaption></td>
        </tr>
        <tr>
          <td><span class="coinrun-action">A</span></td>
          <td><span class="coinrun-action">B</span></td>
          <td><span class="coinrun-action">C</span></td>
          <td><figcaption>A, B and C do nothing.<d-footnote>The original version of CoinRun only has 1 "do nothing" action, but our version ended up with 3 when "A" and "B" actions were added to be used in other games. For consistency, we have relabeled the original "do nothing" action as "C".</d-footnote></figcaption></td>
        </tr>
      </table>
    </figure>
    <p>
      We trained a convolutional neural network<d-footnote>Our architecture consists of the following layers in the order given, together with ReLU activations for all except the final layer.<br>- 7x7 convolutional layer with 16 channels (layer 1a)<br>- 2x2 L2 pooling layer<br>- 5x5 convolutional layer with 32 channels (layer 2a)<br>- 5x5 convolutional layer with 32 channels (layer 2b)<br>- 2x2 L2 pooling layer<br>- 5x5 convolutional layer with 32 channels (layer 3a)<br>- 2x2 L2 pooling layer<br>- 5x5 convolutional layer with 32 channels (layer 4a)<br>- 2x2 L2 pooling layer<br>- 256-unit dense layer<br>- 512-unit dense layer<br>- 10-unit dense layer (1 unit for the value function, 9 units for the policy logits)<br><br>We designed this architecture by starting with the architecture from IMPALA <d-cite key="impala"></d-cite>, and making the following modifications in an attempt to aid interpretability without noticeably sacrificing performance.<br>- We used fewer convolutional layers and more dense layers, to allow for more non-visual processing.<br>- We removed the residual connections, so that the flow of information passes through every layer.<br>- We made the pool size equal to the pool stride, to avoid gradient gridding.<br>- We used L2 pooling instead of max pooling, for more continuous gradients.<br><br>The choice that seemed to make the most difference was using 5 rather than 12 convolutional layers, resulting in the object-identifying features (which were the most interpretable, as discussed <a href="#diversity-hypothesis">below</a>) being concentrated in a single layer (layer 2b), rather than being spread over multiple layers and mixed in with less interpretable features.</d-footnote> on CoinRun for around 2 billion timesteps, using PPO <d-cite key="ppo"></d-cite>, an actor-critic algorithm.<d-footnote>We used the standard PPO hyperparameters for CoinRun <d-cite key="coinrunpaper"></d-cite>, except that we used twice as many copies of the environment per worker and twice and many workers. The effect of these changes was to increase the effective batch size, which seemed to be necessary to reach the same performance with our smaller architecture.</d-footnote> We used a non-recurrent network, to avoid any need to visualize multiple frames at once. Thus the model takes in a single RGB observation, which has been downsampled to 64x64, and outputs a value function (an estimate of the total future time-discounted reward) and a policy (a probability distribution over the actions, from which the next action is sampled).
    </p>
    <figure style="text-align: center;">
      <svg height="160px" width="448px">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,6 L9,3 z" fill="#000000" />
          </marker>
        </defs>
        <image xlink:href="images/coinrun/observation.png" x="8" y="16" height="96" width="96" style="image-rendering: pixelated;"></image>
        <rect x="8" y="16" height="96" width="96" fill="none" stroke="#808080" stroke-width="1"></rect>
        <text x="56" y="135" text-anchor="middle">observation</text>
        <line x1="104" y1="64" x2="152" y2="64" stroke="#000000" stroke-width="1" marker-end="url(#arrow)"></line>
        <text x="180" y="69" text-anchor="middle">CNN</text>
        <rect x="152" y="36" height="56" width="56" fill="none" stroke="#000000" stroke-width="1"></rect>
        <path d="M 208 64 h 24 q 8 0, 8 -8 v -40 q 0 -8, 8 -8 h 24" fill="none" stroke="#000000" stroke-width="1" marker-end="url(#arrow)"></path>
        <path d="M 232 64 q 8 0, 8 8 q 0 8, 8 8 h 24" fill="none" stroke="#000000" stroke-width="1" marker-end="url(#arrow)"></path>
        <rect x="278" y="0" height="16" width="16" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="4" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <text x="300" y="13" text-anchor="start">value function</text>
        <rect x="278" y="24" height="112" width="16" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="28" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="40" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="52" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="64" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="76" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="88" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="100" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="112" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <rect x="282" y="124" height="8" width="8" fill="none" stroke="#000000" stroke-width="1"></rect>
        <text x="286" y="152" text-anchor="middle">logits</text>
        <line x1="300" y1="80" x2="380" y2="80" stroke="#000000" stroke-width="1" marker-end="url(#arrow)"></line>
        <text x="340" y="102" text-anchor="middle">softmax</text>
        <text x="388" y="84" text-anchor="start">policy</text>
      </svg>
      <figcaption>Schematic of a typical non-recurrent convolutional actor-critic model, such as ours.</figcaption>
    </figure>
    <p>
      Since the only available reward is a fixed bonus for collecting the coin, the value function estimates the time-discounted<d-footnote>We use a discount rate of 0.999 per timestep.</d-footnote> probability that the agent will successfully complete the level.
    </p>
    <h2 id="analysis">Model analysis</h2>
    <p>
      We developed an interface for examining trajectories of the agent playing the game. This incorporates attribution, which highlights objects that positively or negatively influence a particular network output (either the value function, or a policy logit). Using dimensionality reduction, attribution is broken down according to the type of object detected, which we indicate using different colors. (We will explain the precise calculation involved <a href="#attribution">later</a>.)
    </p>
    <p>
      Here is our interface for a typical trajectory, with the value function as the network output. It reveals the model using coins, enemies, walls and more to compute the value function.
    </p>
    <d-figure style="grid-column: page; margin-bottom: 3em;">
      <figure>
        <div id="interface-header-target"></div>
      </figure>
    </d-figure>
    <h3 id="dissecting-failure">Dissecting failure</h3>
    <p>
      Our fully-trained model fails to complete around 1 in every 200 levels. We explored some of these failures using our interface, and found that we were usually able to understand why the failure occurred.
    </p>
    <p>
      Often, the failure boils down to the fact that the model (being non-recurrent) has no memory, and must choose its action based only on the current observation. It is also common for some unlucky sampling of actions from the agent's policy to be partly responsible.
    </p>
    <p>
      Here are some cherry-picked examples of failures, carefully analyzed step-by-step.
    </p>
    <table style="margin-top: 1em; margin-bottom: 1em;">
      <tr>
        <td style="width: 45%; vertical-align: top;">
          <label id="interface-failure-obscured-label" style="color: black;">
            <b><input type="radio" name="interface-failure-options" checked id="interface-failure-obscured-option"> Buzzsaw obstacle obscured by enemy</b>
          </label><br>
          <label id="interface-failure-down-label" style="color: lightgray;">
            <b><input type="radio" name="interface-failure-options" id="interface-failure-down-option"> Stepping down to avoid jumping</b>
          </label><br>
          <label id="interface-failure-offscreen-label" style="color: lightgray;">
            <b><input type="radio" name="interface-failure-options" id="interface-failure-offscreen-option"> Landing platform moving off-screen</b>
          </label>
        </td>
        <td>
          <div style="min-height: 7.5em;">
            <div style="display: block;" id="interface-failure-obscured-text">
              The agent moves too far to the right while in mid-air as a result of a buzzsaw obstacle being temporarily hidden from view by a moving enemy. The buzzsaw comes back into view, but too late to avoid a collision.
            </div>
            <div style="display: none;" id="interface-failure-down-text">
              The agent presses down in a bid to delay a jump. This causes the agent to inadvertently step down from a box and onto an enemy.
            </div>
            <div style="display: none;" id="interface-failure-offscreen-text">
              The agent fails to move far enough to the right while in mid-air, as a result of the platform where it was intending to land moving below the field of view.
            </div>
          </div>
        </td>
      </tr>
    </table>
    <table style="grid-column: page; margin: 0em 2em;">
      <tr>
        <td style="width: 11.5em; white-space: nowrap; vertical-align: top; text-align: center;">
          <div style="display: inline-block;">
            <button id="interface-failure-previous" class="interface-failure-step-button">Prev</button><br>
            <button id="interface-failure-start" class="interface-failure-step-button">Start</button>
          </div>
          <button id="interface-failure-play-pause-button" class="play-pause-button">
            <span id="interface-failure-play-pause-span">&#9658;</span>
          </button>
          <div style="display: inline-block;">
            <button id="interface-failure-next" class="interface-failure-step-button">Next</button><br>
            <button id="interface-failure-end" class="interface-failure-step-button">End</button>
          </div>
          <br>
          <span id="interface-failure-position"></span>
        </td>
        <td style="vertical-align: top;">
          <div id="interface-failure-description" style="position: relative;"></div>
        </td>
      </tr>
    </table>
    <d-figure style="grid-column: page; margin-top: 1em;">
      <figure>
        <div id="interface-failure-obscured-target" style="display: block;"></div>
        <div id="interface-failure-down-target" style="display: none;"></div>
        <div id="interface-failure-offscreen-target" style="display: none;"></div>
      </figure>
    </d-figure>
    <h3 id="error-diagnosis">Error diagnosis</h3>
    <p>
      We searched for errors in the model using generalized advantage estimation (GAE) <d-cite key="gae"></d-cite>,<d-footnote>We use the same GAE hyperparameters as in training, namely <d-math>\gamma=0.999</d-math> and <d-math>\lambda=0.95</d-math>.</d-footnote> which measures how successful each action turned out relative to the agent's expectations. Filtering for timesteps with unusually high or low GAE can find problems with the value function or policy.
    </p>
    <p>
      Using our interface, we found a couple of cases in which the model "hallucinated" a feature not present in the observation, causing the value function to spike.
    </p>
    <table style="margin-top: 1em; margin-bottom: 0em;">
      <tr>
        <td style="width: 35%; vertical-align: top;">
          <label id="interface-bug-coin-label" style="color: black;">
            <b><input type="radio" name="interface-bug-options" id="interface-bug-coin-option" checked> Coin hallucination</b>
          </label><br>
          <label id="interface-bug-saw-label" style="color: lightgray;">
            <b><input type="radio" name="interface-bug-options" id="interface-bug-saw-option"> Buzzsaw hallucination</b>
          </label>
        </td>
        <td>
          <div>
            <div style="display: block;" id="interface-bug-coin-text">
              At one point the value function spiked upwards from 95% to 98% for a single timestep. This was due to a curved yellow-brown shape in the background, which happened to appear next to a wall, being mistaken for a coin.
            </div>
            <div style="display: none;" id="interface-bug-saw-text">
              At another point the value function spiked downwards from 94% to 85% for a single timestep. This was due to the agent, colored in gray-blue and crouching against a mottled background, being mistaken for a buzzsaw. An actual buzzsaw was also present in the observation, but the main effect was from the misjudged agent, as shown by the larger red circle around the agent (hover over the first legend item to isolate).
            </div>
          </div>
        </td>
      </tr>
    </table>
    <d-figure style="grid-column: page; margin-top: 1em;">
      <figure>
        <div id="interface-bug-coin-target" style="display: block;"></div>
        <div id="interface-bug-saw-target" style="display: none;"></div>
      </figure>
    </d-figure>
    <h3 id="model-editing">Model editing</h3>
    <p>
      Our analysis so far has been mostly qualitative. To quantitatively validate our analysis, we hand-edited the model to make the agent blind to certain features: buzzsaw obstacles in one case, and left-moving enemies in another. <d-footnote>The features in our interface correspond to directions in activation space obtained by applying <a href="#dimensionality-reduction">attribution-based NMF</a> to layer 2b of our model. To blind the agent to a feature, we edited the weights to make them project out the corresponding NMF direction.<br><br>More precisely, let <d-math>\mathbf v</d-math> be the NMF direction corresponding to the feature we wish to blind the model to. This is a vector of length <d-math>c</d-math>, the number of channels in activation space. Using this we construct the <a href="https://en.wikipedia.org/wiki/Projection_(linear_algebra)">orthogonal projection</a> matrix <d-math>P:=I-\frac 1{\|\mathbf v\|^2}\mathbf v\mathbf v^{\mathsf T}</d-math>, which projects out the direction of <d-math>\mathbf v</d-math> from activation vectors. We then take the convolutional kernel of the following layer, which has shape <d-math>\text{height}\times\text{width}\times c\times d</d-math>, where <d-math>d</d-math> is the number of output channels. Broadcasting across the height and width dimensions, we left-multiply each <d-math>c\times d</d-math> matrix in the kernel by <d-math>P</d-math>. The effect of the new kernel is to project out the direction of <d-math>\mathbf v</d-math> from activations before applying the original kernel.<br><br>As it turned out, the NMF directions were close to one-hot, so this procedure was approximately equivalent to zeroing out the slice of the kernel corresponding to a particular in-channel.</d-footnote> The idea of weight editing originated in forthcoming research <d-cite key="circuits"></d-cite>, where it will be explored much more thoroughly.
    </p>
    <p>
      We evaluated each edit by measuring the percentage of levels that the new agent failed to complete, broken down by the direct cause of failure. Our results show that our edits were successful and targeted, with no statistically measurable effects on the agent's other abilities.<d-footnote>The data for this plot are as follows.<br>Percentage of levels failed due to: buzzsaw obstacle / enemy moving left / enemy moving right / multiple or other:<br>- Original model: 0.37% / 0.16% / 0.12% / 0.08%<br>- Buzzsaw obstacle blindness: 12.76% / 0.16% / 0.08% / 0.05%<br>- Enemy moving left blindness: 0.36% / 4.69% / 0.97% / 0.07%<br>Each model was tested on 10,000 levels.<br><br>We also tested the original model on a version of the game with invisible buzzsaws, and obtained the following results.<br>Percentage of levels failed due to: buzzsaw obstacle / enemy moving left / enemy moving right / multiple or other:<br>- Original model, invisible buzzsaws: 32.20% / 0.05% / 0.05% / 0.05%<br>So the buzzsaw-edited model is only partially blind to buzzsaws. Its ability to dodge enemies may also be very slightly degraded, though the data is not conclusive.</d-footnote>
    </p>
    <figure class="matplotlib-svg" style="text-align: center;">
      <%= require("../static/diagrams/model_editing_results.svg") %>
      <figcaption>Results of testing each model on 10,000 levels. Note that moving enemies can change direction.</figcaption>
    </figure>
    <p>
      Here are the original and edited models playing some cherry-picked levels.
    </p>
    <figure id="model-editing-levels" style="grid-column: page;">
      <table>
        <tr>
          <td style="vertical-align: top;">
            <label id="model-editing-level-1-label" style="color: black;">
              <b><input type="radio" name="model-editing-level-options" checked id="model-editing-level-1-option"> Level 1</b>
            </label><br>
            <label id="model-editing-level-2-label" style="color: lightgray;">
              <b><input type="radio" name="model-editing-level-options" id="model-editing-level-2-option"> Level 2</b>
            </label><br>
            <label id="model-editing-level-3-label" style="color: lightgray;">
              <b><input type="radio" name="model-editing-level-options" id="model-editing-level-3-option"> Level 3</b>
            </label>
            <div style="margin-top: 1em;">
              <button id="model-editing-level-1-play-pause-button" class="play-pause-button" style="display: block; margin: 0 auto;">
                <span id="model-editing-level-1-play-pause-span">&#9658;</span>
              </button>
              <button id="model-editing-level-2-play-pause-button" class="play-pause-button" style="display: none; margin: 0 auto;">
                <span id="model-editing-level-2-play-pause-span">&#9658;</span>
              </button>
              <button id="model-editing-level-3-play-pause-button" class="play-pause-button" style="display: none; margin: 0 auto;">
                <span id="model-editing-level-3-play-pause-span">&#9658;</span>
              </button>
            </div>
          </td>
          <td>
            <div style="display: block;" id="model-editing-level-1-target-1">
              <video id="model-editing-level-1-video-1" controls>
                <source src="videos/model_editing/original_episode_0.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-2-target-1">
              <video id="model-editing-level-2-video-1" controls>
                <source src="videos/model_editing/original_episode_1.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-3-target-1">
              <video id="model-editing-level-3-video-1" controls>
                <source src="videos/model_editing/original_episode_2.mp4" type="video/mp4">
              </video>
            </div>
          </td>
          <td>
            <div style="display: block;" id="model-editing-level-1-target-2">
              <video id="model-editing-level-1-video-2" controls>
                <source src="videos/model_editing/saw_episode_0.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-2-target-2">
              <video id="model-editing-level-2-video-2" controls>
                <source src="videos/model_editing/saw_episode_1.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-3-target-2">
              <video id="model-editing-level-3-video-2" controls>
                <source src="videos/model_editing/saw_episode_2.mp4" type="video/mp4">
              </video>
            </div>
          </td>
          <td>
            <div style="display: block;" id="model-editing-level-1-target-3">
              <video id="model-editing-level-1-video-3" controls>
                <source src="videos/model_editing/enemy_episode_0.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-2-target-3">
              <video id="model-editing-level-2-video-3" controls>
                <source src="videos/model_editing/enemy_episode_1.mp4" type="video/mp4">
              </video>
            </div>
            <div style="display: none;" id="model-editing-level-3-target-3">
              <video id="model-editing-level-3-video-3" controls>
                <source src="videos/model_editing/enemy_episode_2.mp4" type="video/mp4">
              </video>
            </div>
          </td>
        </tr>
        <tr>
          <td></td>
          <td><figcaption>Original model.</figcaption></td>
          <td><figcaption>Buzzsaw obstacle blindness.</figcaption></td>
          <td><figcaption>Enemy moving left blindness.</figcaption></td>
        </tr>
      </table>
    </figure>
    <h2 id="diversity-hypothesis">The diversity hypothesis</h2>
    <p>
      We formulate the following <span style="font-style: italic;">diversity hypothesis</span>.
    </p>
    <blockquote>
      Interpretable features tend to arise (at a given level of abstraction) if and only if the training distribution is diverse enough (at that level of abstraction).
    </blockquote>
    <p>
      Our reasoning behind this hypothesis is as follows. For the forward implication ("only if"), we only expect features to be interpretable if they are general enough, and when the training distribution is not diverse enough, models have no incentive to develop features that generalize instead of overfitting. For the reverse implication ("if"), while diversity on its own is not enough to guarantee the development of interpretable features (they must also be relevant to the task), diversity tends to be a key bottleneck in typical training processes.
    </p>
    <p>
      In CoinRun, this diversity is provided by procedural generation (meaning that each new level encountered by the agent is randomly generated from scratch). This incentivizes the model to learn to recognize relevant objects, so that the agent's skills generalize to unseen layouts <d-cite key="procgen,gvgai,obstacletower"></d-cite>. By contrast, when models are trained to play video games with a limited number of levels, they tend to heavily overfit, memorizing the levels using irrelevant background objects <d-cite key="sonicsaliency"></d-cite>.
    </p>
    <p>
      Conversely, CoinRun is <span style="font-style: italic;">not</span> diverse in other respects: the low-level visual patterns and high-level dynamics rules are very consistent between levels. Correspondingly, the lower-level and higher-level features of our model are harder to interpret than the mid-level features that pick out objects. When our techniques are applied to earlier layers, the features seem to mostly pick out specific color configurations, and when they are applied to later layers, the features involve mixtures of combinations of objects that are hard to decipher. (An interface for all convolutional layers can be viewed <a href="https://storage.googleapis.com/clarity-public/jhilton/attribution/demo/interface.html" target="_blank">here</a>.) This is the sense in which we relativize (in parentheses) the diversity hypothesis to a specific level of abstraction.
    </p>
    <h3 id="interpretability-and-generalization">Interpretability and generalization</h3>
    <p>
      To test our hypothesis, we made the training distribution less diverse, by training the agent on a fixed set of 100 levels. This dramatically reduced our ability to interpret the model's features. Here we display an interface for the new model, generated in the same way as the one <a href="#analysis">above</a>. The smoothly increasing value function shows that the model has memorized the number of timesteps until the end of the level, and the features it uses for this focus on irrelevant background objects.
    </p>
    <d-figure style="grid-column: page; margin-bottom: 3em;">
      <figure>
        <div id="interface-100-levels-target"></div>
      </figure>
    </d-figure>
    <p>
      We attempted to quantify this effect by varying the number of levels used to train the agent, and evaluating the 8 features identified by our interface on how interpretable they were.<d-footnote>The interfaces used for this evaluation can be found <a href="https://storage.googleapis.com/clarity-public/jhilton/attribution/finite_levels/index.html" target="_blank">here</a>.</d-footnote> Features were scored based on how consistently they focused on the same objects, and whether the value function attribution made sense (for example, background objects should not be relevant). This process was subjective and noisy, but that may be unavoidable. We also measured the generalization ability of each model, by testing the agent on unseen levels <d-cite key="coinrunpaper"></d-cite>.<d-footnote>The data for this plot are as follows.<br>- Number of training levels: 100 / 300 / 1000 / 3,000 / 10,000 / 30,000 / 100,000<br>- Percentage of levels completed (train, run 1): 99.96% / 99.82% / 99.67% / 99.65% / 99.47% / 99.55% / 99.57%<br>- Percentage of levels completed (train, run 2): 99.97% / 99.86% / 99.70% / 99.46% / 99.39% / 99.50% / 99.37%<br>- Percentage of levels completed (test, run 1): 61.81% / 66.95% / 74.93% / 89.87% / 97.53% / 98.66% / 99.25%<br>- Percentage of levels completed (test, run 2): 64.13% / 67.64% / 73.46% / 90.36% / 97.44% / 98.89% / 99.35%<br>- Percentage of features interpretable (researcher 1, run 1): 52.5% / 22.5% / 11.25% / 45% / 90% / 75% / 91.25%<br>- Percentage of features interpretable (researcher 2, run 1): 8.75% / 8.75% / 10% / 26.25% / 56.25% / 90% / 70%<br>- Percentage of features interpretable (researcher 1, run 2): 15% / 13.75% / 15% / 23.75% / 53.75% / 90% / 96.25%<br>- Percentage of features interpretable (researcher 2, run 2): 3.75% / 6.25% / 21.25% / 45% / 72.5% / 83.75% / 77.5%<br>Percentages of levels completed are estimated by sampling 10,000 levels with replacement.</d-footnote>
    </p>
    <figure class="matplotlib-svg">
      <%= require("../static/diagrams/generalization_results.svg") %>
      <figcaption>Comparison of models trained on different numbers of levels. Two models were trained for each number of levels, and two researchers independently evaluated how interpretable the features of each model were, without being shown the number of levels.<d-footnote>Our methodology had some flaws. Firstly, the researchers were not completely blind to the number of levels: for example, it is possible to infer something about the number of levels from the smoothness of graphs of the value function, since with fewer levels the model is better able to memorize the number of timesteps until the end of the level. Secondly, since evaluations are somewhat tedious, we stopped them once we thought the trend had become clear, introducing some selection bias. Therefore these results should be considered primarily illustrative.</d-footnote> Each model was tested on 10,000 train and 10,000 test levels sampled with replacement. Shaded areas in the left plot show the range of values over both models (though these are mostly too narrow to be visible). Error bars in the right plot show &plusmn;1 population standard deviation over all four model&ndash;researcher pairs.</figcaption>
    </figure>
    <p>
      Our results illustrate how diversity may lead to interpretable features via generalization, lending support to the diversity hypothesis.
    </p>
    <h2 id="feature-visualization">Feature visualization</h2>
    <p>
      <a href="https://distill.pub/2017/feature-visualization/">Feature visualization</a> <d-cite key="attribution1,featurevis,featurevis1,featurevis2,featurevis3,featurevis4"></d-cite> answers questions about what certain parts of a networkâ€‰are looking for by generating examples. This can be done by applying gradient descent to the input image, starting from random noise, with the objective of activating a particular neuron, or group of neurons. While this method works well for an image classifier trained on ImageNet <d-cite key="imagenet"></d-cite>, for our CoinRun model it yields only featureless clouds of extremal colors. Only for the first layer, which computes simple convolutions of the input, does the method produce comparable visualizations for the two models.
    </p>
    <figure style="grid-column: page;">
      <div style="display: table; margin: 0 auto;">
        <table id="feature-vis-traditional">
          <tr><th></th><th>ImageNet</th><th>CoinRun</th></tr>
          <tr>
            <td>
              First layer
            </td>
            <td>
              <img src="images/feature_vis_traditional/imagenet_first_0.png">
              <img src="images/feature_vis_traditional/imagenet_first_1.png">
              <img src="images/feature_vis_traditional/imagenet_first_2.png">
            </td>
            <td>
              <img src="images/feature_vis_traditional/coinrun_first_0.png">
              <img src="images/feature_vis_traditional/coinrun_first_1.png">
              <img src="images/feature_vis_traditional/coinrun_first_2.png">
            </td>
          </tr>
          <tr>
            <td style="width: 1%;">
              Intermediate layer
            </td>
            <td>
              <img src="images/feature_vis_traditional/imagenet_intermediate_0.png">
              <img src="images/feature_vis_traditional/imagenet_intermediate_1.png">
              <img src="images/feature_vis_traditional/imagenet_intermediate_2.png">
            </td>
            <td>
              <img src="images/feature_vis_traditional/coinrun_intermediate_0.png">
              <img src="images/feature_vis_traditional/coinrun_intermediate_1.png">
              <img src="images/feature_vis_traditional/coinrun_intermediate_2.png">
            </td>
          </tr>
        </table>
        <figcaption style="display: table-caption; caption-side: bottom;">Comparison of gradient-based feature visualization for CNNs trained on ImageNet (GoogLeNet <d-cite key="googlenet"></d-cite>) and on CoinRun (architecture described <a href="#d-footnote-4-listing">below</a>). Each image was chosen to activate a neuron in the center, with the 3 images corresponding to the first 3 channels. Jittering was applied between optimization steps of up to 2 pixels for the first layer, and up to 8 pixels for the intermediate layer (mixed4a for ImageNet, 2b for CoinRun).</figcaption>
      </div>
    </figure>
    <p>
      Gradient-based feature visualization has previously been shown to struggle with RL models trained on Atari games <d-cite key="atarimodelzoo,atarifeaturevis"></d-cite>. To try to get it to work for CoinRun, we varied the method in a number of ways. Nothing we tried had any noticeable effect on the quality of the visualizations.
    </p>
    <ul>
      <li><b>Transformation robustness.</b> This is the method of stochastically jittering, rotating and scaling the image between optimization steps, to search for examples that are robust to these transformations <d-cite key="featurevis"></d-cite>. We tried both increasing and decreasing the size of the jittering. Rotating and scaling are less appropriate for CoinRun, since the observations themselves are not invariant to these transformations.</li>
      <li id="extremal-colors"><b>Penalizing extremal colors.</b><d-footnote>By an "extremal" color we mean one of the 8 colors with maximal or minimal RGB values (black, white, red, green, blue, yellow, cyan and magenta).</d-footnote> Noticing that our visualizations tend to use extremal colors towards the middle, we tried including in the visualization objective an L2 penalty of various strengths on the activations of the first layer, which successfully reduced the size of the extremally-colored region.</li>
      <li><b>Alternative objectives.</b> We tried using an alternative optimization objective <d-cite key="featurevis"></d-cite>, such as the caricature objective <d-cite key="caricatures"></d-cite>.<d-footnote>The caricature objective is to maximize the dot product between the activations of the input image and the activations of a reference image.</d-footnote> We also tried using dimensionality reduction (as described <a href="#dataset-examples">below</a>) to choose non-axis-aligned directions in activation space to maximize.
      <li><b>Low-level visual diversity.</b> In an attempt to broaden the distribution of images seen by the model, we retrained it on a version of the game with procedurally-generated sprites. We additionally tried adding noise to the images, both independent per-pixel noise and spatially-correlated noise. Finally, we experimented briefly with adversarial training <d-cite key="adversarialtraining"></d-cite>, though we did not pursue this line of inquiry very far.</li>
    </ul>
    <p id="feature-visualization-discussion">
      As shown <a href="#dataset-examples">below</a>, we were able to use dataset examples to identify a number of channels that pick out human-interpretable features. It is therefore striking how resistant gradient-based methods were to our efforts. We believe that this is because solving CoinRun does not ultimately require much visual ability. Even with our modifications, it is possible to solve the game use simple visual shortcuts, such as picking out certain small configurations of pixels. These shortcuts work well on the narrow distribution of images on which the model is trained, but behave unpredictably in the full space of images in which gradient-based optimization takes place.
    </p>
    <p>
      If our analysis here is valid, it provides further evidence for the <a href="#diversity-hypothesis">diversity hypothesis</a>, as an example of features that are hard to interpret in the absence of diversity. However, it seems to be a lack of diversity at a low level of abstraction that harms our ability to interpret features at all levels of abstraction, which could be an artefact of the fact that gradient-based feature visualization needs to back-propagate through earlier layers.
    </p>
    <h3 id="dataset-examples">Dataset example-based feature visualization</h3>
    <p>
      As an alternative to gradient-based feature visualization, we use dataset examples. This idea has a long history, and can be thought of as a heavily-regularized form of feature visualization <d-cite key="featurevis,featurevisadversarial"></d-cite>. In more detail, we sample a few thousand infrequent observations from the agent playing the game, and pass them through the model. We then apply a dimensionality reduction method known as non-negative matrix factorization (NMF) to the activation channels <d-cite key="buildingblocks"></d-cite>.<d-footnote>More precisely, we find a non-negative approximate low-rank factorization of the matrix obtained by flattening the spatial dimensions of the activations into the batch dimension. This matrix has one row per observation <i>per spatial position</i> and one column per channel: thus the dimensionality reduction does not use spatial information.</d-footnote> For each of the resulting channels (which correspond to weighted combinations of the original channels), we choose the observations and spatial positions with the strongest activation (with a limited number of examples per position, for diversity), and display a patch from the observation at that position.
    </p>
    <figure>
      <div id="feature-vis-dataset">
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_0.png"><div class="feature-vis-dataset-text">Short left-facing wall</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_1.png"><div class="feature-vis-dataset-text">Velocity info or left edge of screen</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_2.png"><div class="feature-vis-dataset-text">Long left-facing wall</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_3.png"><div class="feature-vis-dataset-text">Left end of platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_4.png"><div class="feature-vis-dataset-text">Right end of platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_5.png"><div class="feature-vis-dataset-text">Buzzsaw obstacle or platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_6.png"><div class="feature-vis-dataset-text">Coin</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_7.png"><div class="feature-vis-dataset-text">Top/right edge of screen</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_8.png"><div class="feature-vis-dataset-text">Left end of platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_9.png"><div class="feature-vis-dataset-text">Step</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_10.png"><div class="feature-vis-dataset-text">Agent or enemy moving right</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_11.png"><div class="feature-vis-dataset-text">Left edge of box</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_12.png"><div class="feature-vis-dataset-text">Right end of platform</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_13.png"><div class="feature-vis-dataset-text">Buzzsaw obstacle</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_14.png"><div class="feature-vis-dataset-text">Top left corner of box</div></div>
        <div class="feature-vis-dataset-item"><img src="images/feature_vis_dataset/layer_2b_feature_15.png"><div class="feature-vis-dataset-text">Left end of platform or bottom/right of screen?</div></div>
      </div>
      <figcaption>Dataset example-based feature visualizations for 16 NMF directions of layer 2b of our CoinRun model. The grey-white checkerboard represents the edge of the screen. The labels are hand-composed.</figcaption>
    </figure>
    <p>
      Unlike gradient-based feature visualization, this method finds some meaning to the different directions in activation space. It may still fail to provide a complete picture for each direction, however, since it only shows a limited number of dataset examples, and with limited context.
    </p>
    <h3 id="feature-visualization-spatial">Spatially-aware feature visualization</h3>
    <p>
      CoinRun observations differ from natural images in that they are much less spatially invariant. For example, the agent always appears in the center, and the agent's velocity is always encoded in the top left. As a result, some features detect unrelated things at different spatial positions (such as high horizontal velocity in the top left and coins elsewhere). To account for this, we developed a spatially-aware version of dataset example-based feature visualization, in which we fix each spatial position in turn, and choose the observation with the strongest activation at that position (with a limited number of reuses of the same observation, for diversity). This creates a spatial correspondence between visualizations and observations.
    </p>
    <figure>
      <div id="feature-vis-spatial" class="striped">
        <img src="images/feature_vis_spatial.png">
      </div>
      <figcaption>Spatially-aware dataset example-based feature visualizations for the coin-detecting NMF direction of layer 2b. The feature also responds strongly in the very top left square when the velocity info there is white, meaning that agent's horizontal velocity is high. Transparency (revealing the diagonally-striped background) indicates a weak response, so the left half of the visualization is mostly transparent because coins never appear in the left half of observations.</figcaption>
    </figure>
    <h2 id="attribution">Attribution</h2>
    <p>
      Attribution <d-cite key="attribution1,attribution2,attribution3,gradcam,attribution4,attribution5,attribution6,integratedgradients"></d-cite> answers questions about the relationships between neurons. It is most commonly used to see how the input to a network affects a particular output <d-cite key="perturbationsaliency"></d-cite>, but it can also applied to the activations of hidden layers <d-cite key="buildingblocks"></d-cite>. Although there are many approaches to attribution we could have used, we chose the popular method of integrated gradients <d-cite key="integratedgradients"></d-cite>. In this section, we explain the application of integrated gradients to a hidden layer, which allows us see how the activations affect the value function (the model's estimate of the time-discounted probability that the agent will successfully complete the level).
    </p>
    <div>
      <div style="float: right;">
        <figure style="width: 300px; margin: 0.5em 0.5em 1em 1em;">
          <svg height="160px" width="300px">
            <defs>
              <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L0,6 L9,3 z" fill="#000000" />
              </marker>
            </defs>
            <line x1="100" y1="30" x2="210" y2="30" stroke="#000000" stroke-width="1" marker-end="url(#arrow)"></line>
            <line x1="80" y1="50" x2="110" y2="100" stroke="#000000" stroke-width="1" marker-end="url(#arrow)"></line>
            <line x1="190" y1="100" x2="220" y2="50" stroke="#000000" stroke-width="1" marker-end="url(#arrow)"></line>
            <text x="50" y="20" text-anchor="middle">observation</text>
            <text x="50" y="40" text-anchor="middle">space</text>
            <text x="230" y="35" text-anchor="middle" class="katex"><tspan class="mathbb">R</tspan></text>
            <text x="150" y="120" text-anchor="middle">activation</text>
            <text x="150" y="140" text-anchor="middle">space</text>
            <text x="155" y="20" text-anchor="middle" class="katex"><tspan class="mathit">V</tspan></text>
            <text x="80" y="90" text-anchor="middle" class="katex"><tspan class="mathbf">A</tspan></text>
            <text x="220" y="90" text-anchor="middle" class="katex"><tspan class="mathit">F</tspan></text>
          </svg>
          <figcaption>The <a href="https://en.wikipedia.org/wiki/Commutative_diagram">diagram</a> defining <d-math>F</d-math>, whose gradient we take.</figcaption>
        </figure>
      </div>
      <p>
        Let <d-math>V:\mathbb R^{64\times 64\times 3}\to\mathbb R</d-math> be the value function computed by our network, which accepts a 64x64 RGB observation. Given any layer in the network, we may write <d-math>V</d-math> as <d-math>V\left(\mathbf x\right)=F\left(\mathbf A\left(\mathbf x\right)\right)</d-math>, where <d-math>\mathbf A</d-math> computes the layer's activations. Given an observation <d-math>\mathbf x</d-math>, a simple method of attribution is to compute <d-math>\nabla_{\mathbf a}F\left(\mathbf a\right)\odot\mathbf a</d-math>, where <d-math>\mathbf a=\mathbf A\left(\mathbf x\right)</d-math> and <d-math>\odot</d-math> denotes the pointwise product. This tells us the sensitivity of the value function to each activation, multiplied by the strength of that activation. However, it does not account for the fact that the sensitivity of the value function may change as the activation is increased from zero.
      </p>
    </div>
    <div>
      <div style="float: right;">
        <figure style="width: 300px; margin: 0.5em 0.5em 1em 1em;">
          <img src="images/integrated_gradient.png">
          <figcaption>Viewing <d-math>F</d-math> as the height of a surface, the integrated gradient of <d-math>F</d-math> measures the elevation gained while traveling in each direction, and sums to the total elevation gain <d-cite key="attributionpaths"></d-cite>.</figcaption>
        </figure>
      </div>
      <p>
        To account for this, we instead choose a path <d-math>\mathcal P</d-math> in activation space from some starting point <d-math>\mathbf a_0</d-math> to the ending point <d-math>\mathbf a_1:=\mathbf A\left(\mathbf x\right)</d-math>. We then compute the integrated gradient of <d-math>F</d-math> along <d-math>\mathcal P</d-math>, which is defined as the path integral <d-math block="">\int_{\mathcal P}\nabla_{\mathbf a}F\left(\mathbf a\right)\odot\mathrm d\mathbf a.</d-math> Note the use of the pointwise product rather than the usual dot product here, which makes the integral vector-valued. By the <a href="https://en.wikipedia.org/wiki/Gradient_theorem">fundamental theorem of calculus for line integrals</a>, when the components of this integral are summed, the result depends only on the endpoints <d-math>\mathbf a_0</d-math> and <d-math>\mathbf a_1</d-math>, equaling <d-math>F\left(\mathbf a_1\right)-F\left(\mathbf a_0\right)</d-math>. Thus the components of the integral provide a true decomposition of this difference, "attributing" it across the activations.
      </p>
    </div>
    <p style="margin-bottom: 0;">
      For our purposes, we take <d-math>\mathcal P</d-math> to be the straight line from <d-math>\mathbf 0</d-math> to <d-math>\mathbf A\left(\mathbf x\right)</d-math>.<d-footnote>In theory, we could choose any point in activation space as the starting point of our path, but in practice, <d-math>\mathbf 0</d-math> tends to be a good baseline against which to compare other activations, with <d-math>F\left(\mathbf 0\right)</d-math> being on the same order as the average value function. Sundararajan, Taly and Yan <d-cite key="integratedgradients"></d-cite> discuss the choice of this baseline in more depth.</d-footnote> In other words, given an observation <d-math>\mathbf x</d-math>, we define the value function attribution as<d-footnote>In practice, we numerically approximate the integral by evaluating the integrand at <d-math>\alpha=0.1,0.2,\ldots,1</d-math>.</d-footnote>
    </p>
    <d-math block="" style="margin: 0 auto;">
      \int_0^1\nabla_{\mathbf a}F\left(\alpha\mathbf A\left(\mathbf x\right)\right)\mathrm d\alpha\odot\mathbf A\left(\mathbf x\right).
    </d-math>
    <p>
      This has the same dimensions as <d-math>\mathbf A\left(\mathbf x\right)</d-math>, and its components sum to <d-math>V\left(\mathbf x\right)-F\left(\mathbf 0\right)</d-math>. So for a convolutional layer, this method allows us to attribute the value function (in excess of the baseline <d-math>F\left(\mathbf 0\right)</d-math>) across the horizontal, vertical and channel dimensions of activation space. Positive value function attribution can be thought of as "good news", components that cause the agent to think it is more likely to collect the coin at the end of the level. Similarly, negative value function attribution can be thought of as "bad news".
    </p>
    <h3 id="dimensionality-reduction">Dimensionality reduction for attribution</h3>
    <p>
      We showed <a href="#dataset-examples">above</a> that a dimensionality reduction method known as non-negative matrix factorization (NMF) could be applied to the channels of activations to produce meaningful directions in activation space <d-cite key="buildingblocks"></d-cite>. We have in fact found that it is even more effective to apply NMF not to activations, but to <span style="font-style: italic;">value function attributions</span><d-footnote>As before, we obtain the NMF directions by sampling a few thousand infrequent observations from the agent playing the game, computing the attributions, flattening the spatial dimensions into the batch dimension, and applying NMF.</d-footnote> (working around the fact that NMF can only be applied to non-negative matrices<d-footnote>Our workaround is to separate out the positive and negative parts of the attributions and concatenate them along the batch dimension. We could also have concatenated them along the channel dimension.</d-footnote>). When reducing to enough dimensions, both methods tend to produce similar results, but when reducing to a smaller number of dimensions, using attributions usually produces more salient features. This is because attribution takes into account not just <span style="font-style: italic;">what neurons respond to</span> but also <span style="font-style: italic;">whether their response matters</span>.
    </p>
    <p>
      Moreover, applying NMF to attributions enables us to visualize the attributions themselves, by assigning a different color to each of the resulting channels <d-cite key="buildingblocks"></d-cite>. These visualizations can be overlaid over the observation <d-cite key="gradcam"></d-cite> and combined with dataset example-based feature visualization <d-cite key="buildingblocks"></d-cite> to create a basic version of our interface, allowing us to see the effect of the main features at different spatial positions.
    </p>
    <figure style="grid-column: page;">
      <div id="attribution-demo" style="display: table; margin: 0 auto; width: 100%;">
        <table style="margin-bottom: 1em; width: 100%;">
          <tr><th>Negative attribution <span style="font-weight: normal;">(bad news)</span></th><th>Observation</th><th>Positive attribution <span style="font-weight: normal;">(good news)</span></th></tr>
          <tr>
            <td>
              <div class="attribution-outer">
                <div class="attribution-inner" style="z-index: 0;">
                  <div class="attribution-image" style="background-image: url('images/attribution/observation_grayscale.png');"></div>
                </div>
                <div class="attribution-inner" style="z-index: 1;">
                  <div id="attribution-overlay-neg" class="attribution-image" style="background-image: url('images/attribution/attribution_neg.png');"></div>
                </div>
              </div>
            </td>
            <td>
              <div class="attribution-outer">
                <div class="attribution-inner" style="z-index: 0;">
                  <div class="attribution-image" style="background-image: url('images/attribution/observation.png');"></div>
                </div>
              </div>
            </td>
            <td>
              <div class="attribution-outer">
                <div class="attribution-inner" style="z-index: 0;">
                  <div class="attribution-image" style="background-image: url('images/attribution/observation_grayscale.png');"></div>
                </div>
                <div class="attribution-inner" style="z-index: 1;">
                  <div id="attribution-overlay-pos" class="attribution-image" style="background-image: url('images/attribution/attribution_pos.png');"></div>
                </div>
              </div>
            </td>
          </tr>
        </table>
        <div style="text-align: center; margin-bottom: 0.5em;">
          <span style="font-weight: bold; border-bottom: 1px solid lightgray;">Legend <span style="font-weight: normal;">(hover to isolate)</span></span>
          <br>
          <div id="attribution-legend-item-0" class="attribution-legend-item">
            <div class="attribution-legend-outer">
              <div class="attribution-legend-dot" style="background-color: #ff0000;"></div>
              <div class="attribution-legend-inner">
                <div class="attribution-image" style="background-image: url('images/attribution/layer_2b_feature_0.png');"></div>
              </div>
              <div class="attribution-legend-label">Buzzsaw<br>obstacle</div>
            </div>
          </div>
          <div id="attribution-legend-item-1" class="attribution-legend-item">
            <div class="attribution-legend-outer">
              <div class="attribution-legend-dot" style="background-color: #ffe400;"></div>
              <div class="attribution-legend-inner">
                <div class="attribution-image" style="background-image: url('images/attribution/layer_2b_feature_1.png');"></div>
              </div>
              <div class="attribution-legend-label">Coin</div>
            </div>
          </div>
          <div id="attribution-legend-item-2" class="attribution-legend-item">
            <div class="attribution-legend-outer">
              <div class="attribution-legend-dot" style="background-color: #a1ff00;"></div>
              <div class="attribution-legend-inner">
                <div class="attribution-image" style="background-image: url('images/attribution/layer_2b_feature_2.png');"></div>
              </div>
              <div class="attribution-legend-label">Enemy<br>moving<br>left</div>
            </div>
          </div>
          <div id="attribution-legend-item-3" class="attribution-legend-item">
            <div class="attribution-legend-outer">
              <div class="attribution-legend-dot" style="background-color: #00ffff;"></div>
              <div class="attribution-legend-inner">
                <div class="attribution-image" style="background-image: url('images/attribution/layer_2b_feature_3.png');"></div>
              </div>
              <div class="attribution-legend-label">Agent<br>or enemy<br>moving right</div>
            </div>
          </div>
        </div>
        <figcaption style="display: table-caption; caption-side: bottom;">
          Value function attribution for a cherry-picked observation using layer 2b of our CoinRun model, reduced to 4 channels using attribution-based NMF. The dataset example-based feature visualizations of these directions reveal much more salient features than the visualizations of the first 4 activation-based NMF directions from the preceding section.
        </figcaption>
      </div>
    </figure>
    <p id="attribution-discussion">
      Attributions for our CoinRun model have some interesting properties that would be unusual for an ImageNet model.
    </p>
    <ul>
      <li><b>Sparsity.</b> Attribution tends to be concentrated in a very small number of spatial positions and channels. (We are referring to post-NMF channels here, though in fact the NMF directions are often close to one-hot, so this would also be true for the original channels.) For example, in the figure above, the top 10 position&ndash;channel pairs account for more than 80% of the total absolute attribution. This might be explained by our <a href="#feature-visualization-discussion">earlier</a> hypothesis that the model identifies objects by picking out certain small configurations of pixels. Because of this sparsity, we smooth out attribution over nearby spatial positions for the main version of our interface, so that the amount of visual space taken up can be used to judge attribution strength. This trades off some spatial precision for more precision with magnitudes.</li>
      <li><b>Unexpected sign.</b> Value function attribution usually has the sign one would expect: positive for coins, negative for enemies, and so on. However, this is sometimes not the case. For example, in the figure above, the red channel (which detects buzzsaw obstacles) has both positive and negative attribution in two neighboring spatial positions towards the left. Our best guess is that this phenomenon is a result of statistical <a href="https://en.wikipedia.org/wiki/Multicollinearity">collinearity</a>, caused by certain correlations in the procedural level generation together with the agent's behavior. These could be visual, such as correlations between nearby pixels, or more abstract, such as both coins and long walls appearing at the end of every level. As a toy example, supposing the value function ought to increase by 2% when the end of the level becomes visible, the model could either increase the value function by 1% for coins and 1% for long walls, or by 3% for coins and &minus;1% for long walls, and the effect would be similar.</li>
      <li><b>Outlier frames.</b> When an unusual event causes the network to output extreme values, attribution can behave particularly strangely. For example, in the <a id="bug-saw-link" href="#error-diagnosis">buzzsaw hallucination</a> frame, most features have a significant amount of both positive and negative attribution. We do not have a good explanation for this, but perhaps features are interacting in more complicated ways than usual. Moreover, in these cases there is often a significant component of the attribution lying outside the space spanned by the NMF directions (which we sometimes display as an additional "residual" feature). This could be because each frame is weighted equally when computing NMF, so outlier frames have little influence over the NMF directions.</li>
    </ul>
    <p>
      These considerations suggest that some care may be required when interpreting attributions.
    </p>
    <h2 id="questions">Questions for further research</h2>
    <h3>The <a href="#diversity-hypothesis">diversity hypothesis</a></h3>
    <ol>
      <li><b>Validity.</b> Does the diversity hypothesis hold in other contexts, both within and outside of reinforcement learning?</li>
      <li><b>Relationship to generalization.</b> What is the three-way relationship between diversity, interpretable features and generalization? Do non-interpretable features indicate that a model will fail to generalize in certain ways? Generalization refers implicitly to an underlying distribution &ndash; how should this distribution be chosen?<d-footnote>For example, to measure generalization for CoinRun models trained on a limited number of levels, we used the distribution over all possible procedurally-generated levels. However, to formalize the sense in which CoinRun is not diverse in its visual patterns or dynamics rules, one would need a distribution over levels from a wider class of games.</d-footnote></li>
      <li><b>Caveats.</b> How are interpretable features affected by other factors, such as the choice of task or algorithm, and how do these interact with diversity? Even in the absence of diversity, do you eventually get interpretable features with a big enough model, via the double descent phenomenon <d-cite key="doubledescent1,doubledescent2,doubledescent3,doubledescent4"></d-cite>?</li>
      <li><b>Quantification.</b> Can we quantitatively predict how much diversity is needed for interpretable features, perhaps using generalization? Can we be precise about what is meant by an "interpretable feature" and a "level of abstraction"?</li>
    </ol>
    <h3>Interpretability in the absence of diversity</h3>
    <ol>
      <li><b>Pervasiveness of non-diverse features.</b> Do the "non-diverse features" that appear in the absence of diversity remain when diversity is present? Is there a connection between these non-diverse features and the "non-robust features" that have been posited to explain adversarial examples <d-cite key="advexfeatures,advexfeaturesdiscussion"></d-cite>?</li>
      <li><b>Coping with non-diverse levels of abstraction.</b> Are there levels of abstraction at which even broad distributions like ImageNet remain non-diverse, and how can we best interpret models at these levels of abstraction?</li>
      <li><b>Gradient-based feature visualization.</b> Why does gradient-based feature visualization <a href="#feature-visualization">break down</a> in the absence of diversity, and can it be made to work using transformation robustness, regularization, data augmentation, adversarial training, or other techniques? What property of the optimization leads to the clouds of <a href="#extremal-colors">extremal colors</a>?</li>
      <li><b>Trustworthiness of dataset examples and attribution.</b> How reliable and trustworthy can we make very heavily-regularized versions of feature visualization, such as those based on <a href="#dataset-examples">dataset examples</a>?<d-footnote>Heavily-regularized feature visualization may fail to separate the things causing behavior from things that merely correlate with the causes <d-cite key="featurevis"></d-cite>.</d-footnote> What explains the <a href="#attribution-discussion">strange behavior</a> of attribution, and how trustworthy is it?</li>
    </ol>
    <h3>Interpretability in the RL framework</h3>
    <ol>
      <li><b>Abstract features.</b> For models with interpretable abstract features, such as relationships between objects or anticipated events, will any method of generating examples be enough to understand these, or do we need an entirely new approach? For models with memory, how can we interpret their hidden states <d-cite key="capturetheflag,rubik,dota"></d-cite>?</li>
      <li><b>Improving reliability.</b> How can we best identify, understand and correct rare <a href="#dissecting-failure">failures</a> and <a href="#error-diagnosis">errors</a> in RL models? Can we not only degrade but also improve models by <a href="#model-editing">model editing</a>?</li>
      <li><b>Modifying training.</b> In what ways can we train RL models to make them more interpretable without a significant performance cost, such as by altering architectures or adding auxiliary predictive losses?</li>
      <li><b>Leveraging the environment.</b> How can we enrich interfaces using RL-specific data, such as trajectories of agent&ndash;environment interaction, state distributions, and advantage estimates? What are the benefits of incorporating user&ndash;environment interaction, such as for exploring counterfactuals?</li>
    </ol>
    <h3 id="questions-discussion">What we would like to see from further research and why</h3>
    <p>
      We are motivated to study interpretability for RL for two reasons.
    </p>
    <ul>
      <li><b>To be able to interpret RL models.</b> RL has many real-world applications <d-cite key="rlapplications"></d-cite>, and seems likely to be a part of increasingly influential AI systems. It is therefore important to be able to scrutinize RL models and to understand how they might fail. This may also benefit RL research through an improved understanding of the pitfalls of different algorithms and environments.</li>
      <li><b>As a testbed for interpretability techniques.</b> RL models pose a number of distinctive challenges for interpretability techniques. Notably, environments like CoinRun appear to straddle the boundary between memorization and generalization, making them useful for studying the <a href="#diversity-hypothesis">diversity hypothesis</a> and related ideas.</li>
    </ul>
    <p>
      We think that large neural networks are currently the most likely type of model to be used in highly capable and influential AI systems in the future. Contrary to the traditional perception of neural networks as black boxes, we think that there is a fighting chance that we will be able to clearly and thoroughly understand the behavior even of very large networks. We are therefore most excited by neural network interpretability research that scores highly according to the following criteria.
    </p>
    <ul>
      <li><b>Scalability.</b> The takeaways of the research should have some chance of scaling to harder problems and larger networks. If the techniques themselves do not scale, they should at least reveal some relevant insight that might.</li>
      <li><b>Trustworthiness.</b> Explanations should be faithful to the model. Even if they do not tell the full story, they should at least not be biased in some fatal way (such as by using a misaligned approval-based objective, or by depending on another model that badly distorts information).</li>
      <li><b>Exhaustiveness.</b> This may be turn out to be impossible at scale, but we should strive for techniques that explain every essential feature of our models. If there are theoretical limits to exhaustiveness, we should try to understand these.</li>
      <li><b>Low cost.</b> Our techniques should not be significantly more computationally expensive than training the model. We hope that we will not need to train models differently for them to be interpretable, but if we do, we should try to minimize both the computational expense and any performance cost, so that interpretable models are not disincentivized from being used in practice.</li>
    </ul>
    <p>
      Our proposed questions reflect this perspective. One of the reasons we emphasize diversity relates to exhaustiveness. If "non-diverse features" remain when diversity is present, then our current techniques are not exhaustive, and could end up missing important features of more capable models. Developing tools to understand non-diverse features may shed light on whether this is likely to be a problem.
    </p>
    <p>
      We think there may be significant mileage in simply applying existing interpretability techniques, with attention to detail, to more models. Indeed, this was the mindset with which we initially approached this project. If the diversity hypothesis is correct, then this may become easier as we train our models to perform more complex tasks. Like early biologists encountering a new species, there may be a lot we can glean from taking a magnifying glass to the creatures in front of us.
    </p>
    <h2 id="supplementary-material">Supplementary material</h2>
    <ul>
      <li><b>Code.</b> The <a href-to-be-updated="http://go/rl-clarity-library"><code>rl-clarity</code> library</a> includes code for generating an expanded version of our interface, along with tools for feature visualization, attribution and dimensionality reduction. We demonstrate these tools in a <a href-to-be-updated="http://go/rl-clarity-notebook">Colab notebook</a>. [Links to be updated]</li>
      <li><b>More interfaces.</b> We generated an expanded version of our interface for every convolutional layer in our model <a href="https://storage.googleapis.com/clarity-public/jhilton/attribution/demo/interface.html" target="_blank">here</a>. We also generated interfaces for a number of other models, including the models trained on different numbers of levels, the edited models, and models trained on all 16 of the Procgen Benchmark <d-cite key="procgen"></d-cite> games. These are indexed <a href="https://storage.googleapis.com/clarity-public/jhilton/attribution/index.html" target="_blank">here</a>.</li>
    </ul>

  </d-article>

  <d-appendix id="appendix">
    <h3>Acknowledgments</h3>
    <p>
      We are deeply grateful to...
    </p>

    <h3>Author Contributions</h3>
    <p>
      <b>Research:</b> ...
    </p>

    <d-footnote-list></d-footnote-list>
    <d-citation-list></d-citation-list>
  </d-appendix>

  <d-bibliography src="bibliography.bib"></d-bibliography>

</body>
