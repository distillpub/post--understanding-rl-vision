# A script for extracting the relevant pieces of JSON props from an HTML file
# generated by rl-clarity

import argparse
import json
from lucid.misc.io.reading import read


def main(html_path, *, layer, trajectory, policy):
    trajectory = trajectory - 1
    html = read(html_path, cache=False, mode="r")
    props_str = html.split("</script>", 2)[1].split("<script>", 1)[1]
    props_str = props_str.split("props:", 1)[1].split("\n", 1)[0].strip()
    props = json.loads(props_str)
    props["layers"] = [layer]
    [props["attribution"]] = [
        attribution
        for attribution in props["attributions"]
        if attribution["layer"] == layer and attribution["trajectory"] == trajectory
    ]
    [props["attribution_totals"]] = [
        totals
        for totals in props["attribution_totals"]
        if totals["layer"] == layer and totals["trajectory"] == trajectory
    ]
    props["json_preloaded"] = {
        key: value
        for key, value in props["json_preloaded"].items()
        if not key.startswith("features_grids/")
    }

    def filter_types(item, types):
        new_item = {
            key: value
            if key in ["layer", "trajectory"]
            else (
                {metadata_key: [] for metadata_key in item["metadata"]}
                if key == "metadata"
                else []
            )
            for key, value in item.items()
        }
        for i in range(len(item["metadata"]["type"])):
            if item["metadata"]["type"][i] in types:
                for key in new_item:
                    if key not in ["layer", "trajectory", "metadata"]:
                        new_item[key].append(item[key][i])
                for metadata_key in new_item["metadata"]:
                    new_item["metadata"][metadata_key].append(
                        item["metadata"][metadata_key][i]
                    )
        return new_item

    if policy is None:
        policy = props["attribution_policy"]
    types = ["v", "action"] if policy else ["v"]
    props["attribution_policy"] = policy
    props["attribution"] = filter_types(props["attribution"], types)
    props["attribution_totals"] = filter_types(props["attribution_totals"], types)
    props["trajectories"] = {
        k: [None] * trajectory + [v[trajectory]]
        for k, v in props["trajectories"].items()
    }
    del props["attributions"]
    del props["features"]
    del props["bookmarks"]
    del props["vis_defaults"]
    del props["subdirs"]["observations"]
    del props["subdirs"]["features"]
    del props["formatting"]["feature_viewer_height"]
    del props["formatting"]["feature_viewer_width"]
    print(f"export default {json.dumps(props)};")


def relaxed_bool(s):
    import ast

    if s.lower().startswith("t") or s.lower().startswith("y"):
        return True
    if s.lower().startswith("f") or s.lower().startswith("n"):
        return False
    return bool(ast.literal_eval(s))


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("html_path")
    parser.add_argument("-l", "--layer", default="2b")
    parser.add_argument("-t", "--trajectory", type=int, default=1)
    parser.add_argument("-p", "--policy", type=relaxed_bool)
    args = parser.parse_args()
    main(
        args.html_path, layer=args.layer, trajectory=args.trajectory, policy=args.policy
    )
